Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    COMMENT
    GEQUAL
    GTHAN
    LEQUAL
    WS

Grammar

Rule 0     S' -> prog
Rule 1     prog -> main classes
Rule 2     main -> CLASS ID LCURLY PUBLIC STATIC VOID MAIN LPAREN STRING LBRACKET RBRACKET ID RPAREN LCURLY cmd RCURLY RCURLY
Rule 3     main -> ID LCURLY PUBLIC STATIC VOID MAIN LPAREN STRING LBRACKET RBRACKET ID RPAREN LCURLY cmd RCURLY RCURLY
Rule 4     classes -> classe
Rule 5     classes -> classes classe
Rule 6     classe -> CLASS ID EXTENDS ID LCURLY vars metodos RCURLY
Rule 7     classe -> CLASS ID LCURLY vars metodos RCURLY
Rule 8     vars -> var
Rule 9     vars -> vars var
Rule 10    vars -> empty
Rule 11    var -> tipo ID SEMICOLON
Rule 12    var -> ID ID SEMICOLON
Rule 13    metodos -> metodo
Rule 14    metodos -> metodos metodo
Rule 15    metodo -> PUBLIC tipo ID LPAREN params RPAREN LCURLY vars cmds RETURN exp SEMICOLON RCURLY
Rule 16    metodo -> PUBLIC tipo ID LPAREN RPAREN LCURLY vars cmds RETURN exp SEMICOLON RCURLY
Rule 17    metodo -> PUBLIC ID ID LPAREN params RPAREN LCURLY vars cmds RETURN exp SEMICOLON RCURLY
Rule 18    metodo -> PUBLIC ID ID LPAREN RPAREN LCURLY vars cmds RETURN exp SEMICOLON RCURLY
Rule 19    metodo -> empty
Rule 20    params -> tipo ID
Rule 21    params -> params COMMA tipo ID
Rule 22    params -> ID ID
Rule 23    params -> params COMMA ID ID
Rule 24    tipo -> INT LBRACKET RBRACKET
Rule 25    tipo -> BOOLEAN
Rule 26    tipo -> INT
Rule 27    cmds -> cmd
Rule 28    cmds -> cmds cmd
Rule 29    cmd -> LCURLY cmds RCURLY
Rule 30    cmd -> IF LPAREN exp RPAREN cmd
Rule 31    cmd -> IF LPAREN exp RPAREN cmd ELSE cmd
Rule 32    cmd -> WHILE LPAREN exp RPAREN cmd
Rule 33    cmd -> PRINTLN LPAREN exp RPAREN SEMICOLON
Rule 34    cmd -> ID ASSIGN exp SEMICOLON
Rule 35    cmd -> ID LBRACKET exp RBRACKET ASSIGN exp SEMICOLON
Rule 36    cmd -> empty
Rule 37    exp -> exp AND rexp
Rule 38    exp -> rexp
Rule 39    exp -> empty
Rule 40    rexp -> rexp LTHAN aexp
Rule 41    rexp -> rexp EQUALS aexp
Rule 42    rexp -> rexp DIFFERENT aexp
Rule 43    rexp -> aexp
Rule 44    aexp -> aexp PLUS mexp
Rule 45    aexp -> aexp MINUS mexp
Rule 46    aexp -> mexp
Rule 47    mexp -> mexp TIMES sexp
Rule 48    mexp -> sexp
Rule 49    sexp -> NOT sexp
Rule 50    sexp -> MINUS sexp
Rule 51    sexp -> TRUE
Rule 52    sexp -> FALSE
Rule 53    sexp -> NUMBER
Rule 54    sexp -> NULL
Rule 55    sexp -> NEW INT LBRACKET exp RBRACKET
Rule 56    sexp -> pexp DOT LENGTH
Rule 57    sexp -> ID DOT LENGTH
Rule 58    sexp -> pexp LBRACKET exp RBRACKET
Rule 59    sexp -> ID LBRACKET exp RBRACKET
Rule 60    sexp -> ID
Rule 61    pexp -> THIS
Rule 62    pexp -> NEW ID LPAREN RPAREN
Rule 63    pexp -> LPAREN exp RPAREN
Rule 64    pexp -> pexp DOT ID
Rule 65    pexp -> ID DOT ID
Rule 66    pexp -> pexp DOT ID LPAREN exps RPAREN
Rule 67    pexp -> pexp DOT ID LPAREN RPAREN
Rule 68    pexp -> ID DOT ID LPAREN exps RPAREN
Rule 69    pexp -> ID DOT ID LPAREN RPAREN
Rule 70    exps -> exp
Rule 71    exps -> exps COMMA exp
Rule 72    empty -> <empty>

Terminals, with rules where they appear

AND                  : 37
ASSIGN               : 34 35
BOOLEAN              : 25
CLASS                : 2 6 7
COMMA                : 21 23 71
COMMENT              : 
DIFFERENT            : 42
DOT                  : 56 57 64 65 66 67 68 69
ELSE                 : 31
EQUALS               : 41
EXTENDS              : 6
FALSE                : 52
GEQUAL               : 
GTHAN                : 
ID                   : 2 2 3 3 6 6 7 11 12 12 15 16 17 17 18 18 20 21 22 22 23 23 34 35 57 59 60 62 64 65 65 66 67 68 68 69 69
IF                   : 30 31
INT                  : 24 26 55
LBRACKET             : 2 3 24 35 55 58 59
LCURLY               : 2 2 3 3 6 7 15 16 17 18 29
LENGTH               : 56 57
LEQUAL               : 
LPAREN               : 2 3 15 16 17 18 30 31 32 33 62 63 66 67 68 69
LTHAN                : 40
MAIN                 : 2 3
MINUS                : 45 50
NEW                  : 55 62
NOT                  : 49
NULL                 : 54
NUMBER               : 53
PLUS                 : 44
PRINTLN              : 33
PUBLIC               : 2 3 15 16 17 18
RBRACKET             : 2 3 24 35 55 58 59
RCURLY               : 2 2 3 3 6 7 15 16 17 18 29
RETURN               : 15 16 17 18
RPAREN               : 2 3 15 16 17 18 30 31 32 33 62 63 66 67 68 69
SEMICOLON            : 11 12 15 16 17 18 33 34 35
STATIC               : 2 3
STRING               : 2 3
THIS                 : 61
TIMES                : 47
TRUE                 : 51
VOID                 : 2 3
WHILE                : 32
WS                   : 
error                : 

Nonterminals, with rules where they appear

aexp                 : 40 41 42 43 44 45
classe               : 4 5
classes              : 1 5
cmd                  : 2 3 27 28 30 31 31 32
cmds                 : 15 16 17 18 28 29
empty                : 10 19 36 39
exp                  : 15 16 17 18 30 31 32 33 34 35 35 37 55 58 59 63 70 71
exps                 : 66 68 71
main                 : 1
metodo               : 13 14
metodos              : 6 7 14
mexp                 : 44 45 46 47
params               : 15 17 21 23
pexp                 : 56 58 64 66 67
prog                 : 0
rexp                 : 37 38 40 41 42
sexp                 : 47 48 49 50
tipo                 : 11 15 16 20 21
var                  : 8 9
vars                 : 6 7 9 15 16 17 18

Parsing method: SLR

state 0

    (0) S' -> . prog
    (1) prog -> . main classes
    (2) main -> . CLASS ID LCURLY PUBLIC STATIC VOID MAIN LPAREN STRING LBRACKET RBRACKET ID RPAREN LCURLY cmd RCURLY RCURLY
    (3) main -> . ID LCURLY PUBLIC STATIC VOID MAIN LPAREN STRING LBRACKET RBRACKET ID RPAREN LCURLY cmd RCURLY RCURLY

    CLASS           shift and go to state 3
    ID              shift and go to state 4

    prog                           shift and go to state 1
    main                           shift and go to state 2

state 1

    (0) S' -> prog .



state 2

    (1) prog -> main . classes
    (4) classes -> . classe
    (5) classes -> . classes classe
    (6) classe -> . CLASS ID EXTENDS ID LCURLY vars metodos RCURLY
    (7) classe -> . CLASS ID LCURLY vars metodos RCURLY

    CLASS           shift and go to state 7

    classes                        shift and go to state 5
    classe                         shift and go to state 6

state 3

    (2) main -> CLASS . ID LCURLY PUBLIC STATIC VOID MAIN LPAREN STRING LBRACKET RBRACKET ID RPAREN LCURLY cmd RCURLY RCURLY

    ID              shift and go to state 8


state 4

    (3) main -> ID . LCURLY PUBLIC STATIC VOID MAIN LPAREN STRING LBRACKET RBRACKET ID RPAREN LCURLY cmd RCURLY RCURLY

    LCURLY          shift and go to state 9


state 5

    (1) prog -> main classes .
    (5) classes -> classes . classe
    (6) classe -> . CLASS ID EXTENDS ID LCURLY vars metodos RCURLY
    (7) classe -> . CLASS ID LCURLY vars metodos RCURLY

    $end            reduce using rule 1 (prog -> main classes .)
    CLASS           shift and go to state 7

    classe                         shift and go to state 10

state 6

    (4) classes -> classe .

    $end            reduce using rule 4 (classes -> classe .)
    CLASS           reduce using rule 4 (classes -> classe .)


state 7

    (6) classe -> CLASS . ID EXTENDS ID LCURLY vars metodos RCURLY
    (7) classe -> CLASS . ID LCURLY vars metodos RCURLY

    ID              shift and go to state 11


state 8

    (2) main -> CLASS ID . LCURLY PUBLIC STATIC VOID MAIN LPAREN STRING LBRACKET RBRACKET ID RPAREN LCURLY cmd RCURLY RCURLY

    LCURLY          shift and go to state 12


state 9

    (3) main -> ID LCURLY . PUBLIC STATIC VOID MAIN LPAREN STRING LBRACKET RBRACKET ID RPAREN LCURLY cmd RCURLY RCURLY

    PUBLIC          shift and go to state 13


state 10

    (5) classes -> classes classe .

    $end            reduce using rule 5 (classes -> classes classe .)
    CLASS           reduce using rule 5 (classes -> classes classe .)


state 11

    (6) classe -> CLASS ID . EXTENDS ID LCURLY vars metodos RCURLY
    (7) classe -> CLASS ID . LCURLY vars metodos RCURLY

    EXTENDS         shift and go to state 14
    LCURLY          shift and go to state 15


state 12

    (2) main -> CLASS ID LCURLY . PUBLIC STATIC VOID MAIN LPAREN STRING LBRACKET RBRACKET ID RPAREN LCURLY cmd RCURLY RCURLY

    PUBLIC          shift and go to state 16


state 13

    (3) main -> ID LCURLY PUBLIC . STATIC VOID MAIN LPAREN STRING LBRACKET RBRACKET ID RPAREN LCURLY cmd RCURLY RCURLY

    STATIC          shift and go to state 17


state 14

    (6) classe -> CLASS ID EXTENDS . ID LCURLY vars metodos RCURLY

    ID              shift and go to state 18


state 15

    (7) classe -> CLASS ID LCURLY . vars metodos RCURLY
    (8) vars -> . var
    (9) vars -> . vars var
    (10) vars -> . empty
    (11) var -> . tipo ID SEMICOLON
    (12) var -> . ID ID SEMICOLON
    (72) empty -> .
    (24) tipo -> . INT LBRACKET RBRACKET
    (25) tipo -> . BOOLEAN
    (26) tipo -> . INT

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
    ID              shift and go to state 19
    PUBLIC          reduce using rule 72 (empty -> .)
    RCURLY          reduce using rule 72 (empty -> .)
    RETURN          reduce using rule 72 (empty -> .)
    LCURLY          reduce using rule 72 (empty -> .)
    IF              reduce using rule 72 (empty -> .)
    WHILE           reduce using rule 72 (empty -> .)
    PRINTLN         reduce using rule 72 (empty -> .)
    ELSE            reduce using rule 72 (empty -> .)
    SEMICOLON       reduce using rule 72 (empty -> .)
    RPAREN          reduce using rule 72 (empty -> .)
    RBRACKET        reduce using rule 72 (empty -> .)
    AND             reduce using rule 72 (empty -> .)
    COMMA           reduce using rule 72 (empty -> .)
    INT             shift and go to state 24
    BOOLEAN         shift and go to state 25

  ! ID              [ reduce using rule 72 (empty -> .) ]
  ! INT             [ reduce using rule 72 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 72 (empty -> .) ]

    vars                           shift and go to state 20
    var                            shift and go to state 21
    empty                          shift and go to state 22
    tipo                           shift and go to state 23

state 16

    (2) main -> CLASS ID LCURLY PUBLIC . STATIC VOID MAIN LPAREN STRING LBRACKET RBRACKET ID RPAREN LCURLY cmd RCURLY RCURLY

    STATIC          shift and go to state 26


state 17

    (3) main -> ID LCURLY PUBLIC STATIC . VOID MAIN LPAREN STRING LBRACKET RBRACKET ID RPAREN LCURLY cmd RCURLY RCURLY

    VOID            shift and go to state 27


state 18

    (6) classe -> CLASS ID EXTENDS ID . LCURLY vars metodos RCURLY

    LCURLY          shift and go to state 28


state 19

    (12) var -> ID . ID SEMICOLON

    ID              shift and go to state 29


state 20

    (7) classe -> CLASS ID LCURLY vars . metodos RCURLY
    (9) vars -> vars . var
    (13) metodos -> . metodo
    (14) metodos -> . metodos metodo
    (11) var -> . tipo ID SEMICOLON
    (12) var -> . ID ID SEMICOLON
    (15) metodo -> . PUBLIC tipo ID LPAREN params RPAREN LCURLY vars cmds RETURN exp SEMICOLON RCURLY
    (16) metodo -> . PUBLIC tipo ID LPAREN RPAREN LCURLY vars cmds RETURN exp SEMICOLON RCURLY
    (17) metodo -> . PUBLIC ID ID LPAREN params RPAREN LCURLY vars cmds RETURN exp SEMICOLON RCURLY
    (18) metodo -> . PUBLIC ID ID LPAREN RPAREN LCURLY vars cmds RETURN exp SEMICOLON RCURLY
    (19) metodo -> . empty
    (24) tipo -> . INT LBRACKET RBRACKET
    (25) tipo -> . BOOLEAN
    (26) tipo -> . INT
    (72) empty -> .

  ! shift/reduce conflict for PUBLIC resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
    ID              shift and go to state 19
    PUBLIC          shift and go to state 33
    INT             shift and go to state 24
    BOOLEAN         shift and go to state 25
    RCURLY          reduce using rule 72 (empty -> .)
    RETURN          reduce using rule 72 (empty -> .)
    LCURLY          reduce using rule 72 (empty -> .)
    IF              reduce using rule 72 (empty -> .)
    WHILE           reduce using rule 72 (empty -> .)
    PRINTLN         reduce using rule 72 (empty -> .)
    ELSE            reduce using rule 72 (empty -> .)
    SEMICOLON       reduce using rule 72 (empty -> .)
    RPAREN          reduce using rule 72 (empty -> .)
    RBRACKET        reduce using rule 72 (empty -> .)
    AND             reduce using rule 72 (empty -> .)
    COMMA           reduce using rule 72 (empty -> .)

  ! PUBLIC          [ reduce using rule 72 (empty -> .) ]
  ! ID              [ reduce using rule 72 (empty -> .) ]
  ! INT             [ reduce using rule 72 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 72 (empty -> .) ]

    metodos                        shift and go to state 30
    var                            shift and go to state 31
    metodo                         shift and go to state 32
    tipo                           shift and go to state 23
    empty                          shift and go to state 34

state 21

    (8) vars -> var .

    PUBLIC          reduce using rule 8 (vars -> var .)
    RCURLY          reduce using rule 8 (vars -> var .)
    ID              reduce using rule 8 (vars -> var .)
    INT             reduce using rule 8 (vars -> var .)
    BOOLEAN         reduce using rule 8 (vars -> var .)
    LCURLY          reduce using rule 8 (vars -> var .)
    IF              reduce using rule 8 (vars -> var .)
    WHILE           reduce using rule 8 (vars -> var .)
    PRINTLN         reduce using rule 8 (vars -> var .)
    RETURN          reduce using rule 8 (vars -> var .)


state 22

    (10) vars -> empty .

    PUBLIC          reduce using rule 10 (vars -> empty .)
    RCURLY          reduce using rule 10 (vars -> empty .)
    ID              reduce using rule 10 (vars -> empty .)
    INT             reduce using rule 10 (vars -> empty .)
    BOOLEAN         reduce using rule 10 (vars -> empty .)
    LCURLY          reduce using rule 10 (vars -> empty .)
    IF              reduce using rule 10 (vars -> empty .)
    WHILE           reduce using rule 10 (vars -> empty .)
    PRINTLN         reduce using rule 10 (vars -> empty .)
    RETURN          reduce using rule 10 (vars -> empty .)


state 23

    (11) var -> tipo . ID SEMICOLON

    ID              shift and go to state 35


state 24

    (24) tipo -> INT . LBRACKET RBRACKET
    (26) tipo -> INT .

    LBRACKET        shift and go to state 36
    ID              reduce using rule 26 (tipo -> INT .)


state 25

    (25) tipo -> BOOLEAN .

    ID              reduce using rule 25 (tipo -> BOOLEAN .)


state 26

    (2) main -> CLASS ID LCURLY PUBLIC STATIC . VOID MAIN LPAREN STRING LBRACKET RBRACKET ID RPAREN LCURLY cmd RCURLY RCURLY

    VOID            shift and go to state 37


state 27

    (3) main -> ID LCURLY PUBLIC STATIC VOID . MAIN LPAREN STRING LBRACKET RBRACKET ID RPAREN LCURLY cmd RCURLY RCURLY

    MAIN            shift and go to state 38


state 28

    (6) classe -> CLASS ID EXTENDS ID LCURLY . vars metodos RCURLY
    (8) vars -> . var
    (9) vars -> . vars var
    (10) vars -> . empty
    (11) var -> . tipo ID SEMICOLON
    (12) var -> . ID ID SEMICOLON
    (72) empty -> .
    (24) tipo -> . INT LBRACKET RBRACKET
    (25) tipo -> . BOOLEAN
    (26) tipo -> . INT

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
    ID              shift and go to state 19
    PUBLIC          reduce using rule 72 (empty -> .)
    RCURLY          reduce using rule 72 (empty -> .)
    RETURN          reduce using rule 72 (empty -> .)
    LCURLY          reduce using rule 72 (empty -> .)
    IF              reduce using rule 72 (empty -> .)
    WHILE           reduce using rule 72 (empty -> .)
    PRINTLN         reduce using rule 72 (empty -> .)
    ELSE            reduce using rule 72 (empty -> .)
    SEMICOLON       reduce using rule 72 (empty -> .)
    RPAREN          reduce using rule 72 (empty -> .)
    RBRACKET        reduce using rule 72 (empty -> .)
    AND             reduce using rule 72 (empty -> .)
    COMMA           reduce using rule 72 (empty -> .)
    INT             shift and go to state 24
    BOOLEAN         shift and go to state 25

  ! ID              [ reduce using rule 72 (empty -> .) ]
  ! INT             [ reduce using rule 72 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 72 (empty -> .) ]

    vars                           shift and go to state 39
    var                            shift and go to state 21
    empty                          shift and go to state 22
    tipo                           shift and go to state 23

state 29

    (12) var -> ID ID . SEMICOLON

    SEMICOLON       shift and go to state 40


state 30

    (7) classe -> CLASS ID LCURLY vars metodos . RCURLY
    (14) metodos -> metodos . metodo
    (15) metodo -> . PUBLIC tipo ID LPAREN params RPAREN LCURLY vars cmds RETURN exp SEMICOLON RCURLY
    (16) metodo -> . PUBLIC tipo ID LPAREN RPAREN LCURLY vars cmds RETURN exp SEMICOLON RCURLY
    (17) metodo -> . PUBLIC ID ID LPAREN params RPAREN LCURLY vars cmds RETURN exp SEMICOLON RCURLY
    (18) metodo -> . PUBLIC ID ID LPAREN RPAREN LCURLY vars cmds RETURN exp SEMICOLON RCURLY
    (19) metodo -> . empty
    (72) empty -> .

  ! shift/reduce conflict for PUBLIC resolved as shift
  ! shift/reduce conflict for RCURLY resolved as shift
    RCURLY          shift and go to state 41
    PUBLIC          shift and go to state 33
    ID              reduce using rule 72 (empty -> .)
    INT             reduce using rule 72 (empty -> .)
    BOOLEAN         reduce using rule 72 (empty -> .)
    RETURN          reduce using rule 72 (empty -> .)
    LCURLY          reduce using rule 72 (empty -> .)
    IF              reduce using rule 72 (empty -> .)
    WHILE           reduce using rule 72 (empty -> .)
    PRINTLN         reduce using rule 72 (empty -> .)
    ELSE            reduce using rule 72 (empty -> .)
    SEMICOLON       reduce using rule 72 (empty -> .)
    RPAREN          reduce using rule 72 (empty -> .)
    RBRACKET        reduce using rule 72 (empty -> .)
    AND             reduce using rule 72 (empty -> .)
    COMMA           reduce using rule 72 (empty -> .)

  ! PUBLIC          [ reduce using rule 72 (empty -> .) ]
  ! RCURLY          [ reduce using rule 72 (empty -> .) ]

    metodo                         shift and go to state 42
    empty                          shift and go to state 34

state 31

    (9) vars -> vars var .

    PUBLIC          reduce using rule 9 (vars -> vars var .)
    RCURLY          reduce using rule 9 (vars -> vars var .)
    ID              reduce using rule 9 (vars -> vars var .)
    INT             reduce using rule 9 (vars -> vars var .)
    BOOLEAN         reduce using rule 9 (vars -> vars var .)
    LCURLY          reduce using rule 9 (vars -> vars var .)
    IF              reduce using rule 9 (vars -> vars var .)
    WHILE           reduce using rule 9 (vars -> vars var .)
    PRINTLN         reduce using rule 9 (vars -> vars var .)
    RETURN          reduce using rule 9 (vars -> vars var .)


state 32

    (13) metodos -> metodo .

    RCURLY          reduce using rule 13 (metodos -> metodo .)
    PUBLIC          reduce using rule 13 (metodos -> metodo .)


state 33

    (15) metodo -> PUBLIC . tipo ID LPAREN params RPAREN LCURLY vars cmds RETURN exp SEMICOLON RCURLY
    (16) metodo -> PUBLIC . tipo ID LPAREN RPAREN LCURLY vars cmds RETURN exp SEMICOLON RCURLY
    (17) metodo -> PUBLIC . ID ID LPAREN params RPAREN LCURLY vars cmds RETURN exp SEMICOLON RCURLY
    (18) metodo -> PUBLIC . ID ID LPAREN RPAREN LCURLY vars cmds RETURN exp SEMICOLON RCURLY
    (24) tipo -> . INT LBRACKET RBRACKET
    (25) tipo -> . BOOLEAN
    (26) tipo -> . INT

    ID              shift and go to state 44
    INT             shift and go to state 24
    BOOLEAN         shift and go to state 25

    tipo                           shift and go to state 43

state 34

    (19) metodo -> empty .

    RCURLY          reduce using rule 19 (metodo -> empty .)
    PUBLIC          reduce using rule 19 (metodo -> empty .)


state 35

    (11) var -> tipo ID . SEMICOLON

    SEMICOLON       shift and go to state 45


state 36

    (24) tipo -> INT LBRACKET . RBRACKET

    RBRACKET        shift and go to state 46


state 37

    (2) main -> CLASS ID LCURLY PUBLIC STATIC VOID . MAIN LPAREN STRING LBRACKET RBRACKET ID RPAREN LCURLY cmd RCURLY RCURLY

    MAIN            shift and go to state 47


state 38

    (3) main -> ID LCURLY PUBLIC STATIC VOID MAIN . LPAREN STRING LBRACKET RBRACKET ID RPAREN LCURLY cmd RCURLY RCURLY

    LPAREN          shift and go to state 48


state 39

    (6) classe -> CLASS ID EXTENDS ID LCURLY vars . metodos RCURLY
    (9) vars -> vars . var
    (13) metodos -> . metodo
    (14) metodos -> . metodos metodo
    (11) var -> . tipo ID SEMICOLON
    (12) var -> . ID ID SEMICOLON
    (15) metodo -> . PUBLIC tipo ID LPAREN params RPAREN LCURLY vars cmds RETURN exp SEMICOLON RCURLY
    (16) metodo -> . PUBLIC tipo ID LPAREN RPAREN LCURLY vars cmds RETURN exp SEMICOLON RCURLY
    (17) metodo -> . PUBLIC ID ID LPAREN params RPAREN LCURLY vars cmds RETURN exp SEMICOLON RCURLY
    (18) metodo -> . PUBLIC ID ID LPAREN RPAREN LCURLY vars cmds RETURN exp SEMICOLON RCURLY
    (19) metodo -> . empty
    (24) tipo -> . INT LBRACKET RBRACKET
    (25) tipo -> . BOOLEAN
    (26) tipo -> . INT
    (72) empty -> .

  ! shift/reduce conflict for PUBLIC resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
    ID              shift and go to state 19
    PUBLIC          shift and go to state 33
    INT             shift and go to state 24
    BOOLEAN         shift and go to state 25
    RCURLY          reduce using rule 72 (empty -> .)
    RETURN          reduce using rule 72 (empty -> .)
    LCURLY          reduce using rule 72 (empty -> .)
    IF              reduce using rule 72 (empty -> .)
    WHILE           reduce using rule 72 (empty -> .)
    PRINTLN         reduce using rule 72 (empty -> .)
    ELSE            reduce using rule 72 (empty -> .)
    SEMICOLON       reduce using rule 72 (empty -> .)
    RPAREN          reduce using rule 72 (empty -> .)
    RBRACKET        reduce using rule 72 (empty -> .)
    AND             reduce using rule 72 (empty -> .)
    COMMA           reduce using rule 72 (empty -> .)

  ! PUBLIC          [ reduce using rule 72 (empty -> .) ]
  ! ID              [ reduce using rule 72 (empty -> .) ]
  ! INT             [ reduce using rule 72 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 72 (empty -> .) ]

    metodos                        shift and go to state 49
    var                            shift and go to state 31
    metodo                         shift and go to state 32
    tipo                           shift and go to state 23
    empty                          shift and go to state 34

state 40

    (12) var -> ID ID SEMICOLON .

    PUBLIC          reduce using rule 12 (var -> ID ID SEMICOLON .)
    RCURLY          reduce using rule 12 (var -> ID ID SEMICOLON .)
    ID              reduce using rule 12 (var -> ID ID SEMICOLON .)
    INT             reduce using rule 12 (var -> ID ID SEMICOLON .)
    BOOLEAN         reduce using rule 12 (var -> ID ID SEMICOLON .)
    LCURLY          reduce using rule 12 (var -> ID ID SEMICOLON .)
    IF              reduce using rule 12 (var -> ID ID SEMICOLON .)
    WHILE           reduce using rule 12 (var -> ID ID SEMICOLON .)
    PRINTLN         reduce using rule 12 (var -> ID ID SEMICOLON .)
    RETURN          reduce using rule 12 (var -> ID ID SEMICOLON .)


state 41

    (7) classe -> CLASS ID LCURLY vars metodos RCURLY .

    $end            reduce using rule 7 (classe -> CLASS ID LCURLY vars metodos RCURLY .)
    CLASS           reduce using rule 7 (classe -> CLASS ID LCURLY vars metodos RCURLY .)


state 42

    (14) metodos -> metodos metodo .

    RCURLY          reduce using rule 14 (metodos -> metodos metodo .)
    PUBLIC          reduce using rule 14 (metodos -> metodos metodo .)


state 43

    (15) metodo -> PUBLIC tipo . ID LPAREN params RPAREN LCURLY vars cmds RETURN exp SEMICOLON RCURLY
    (16) metodo -> PUBLIC tipo . ID LPAREN RPAREN LCURLY vars cmds RETURN exp SEMICOLON RCURLY

    ID              shift and go to state 50


state 44

    (17) metodo -> PUBLIC ID . ID LPAREN params RPAREN LCURLY vars cmds RETURN exp SEMICOLON RCURLY
    (18) metodo -> PUBLIC ID . ID LPAREN RPAREN LCURLY vars cmds RETURN exp SEMICOLON RCURLY

    ID              shift and go to state 51


state 45

    (11) var -> tipo ID SEMICOLON .

    PUBLIC          reduce using rule 11 (var -> tipo ID SEMICOLON .)
    RCURLY          reduce using rule 11 (var -> tipo ID SEMICOLON .)
    ID              reduce using rule 11 (var -> tipo ID SEMICOLON .)
    INT             reduce using rule 11 (var -> tipo ID SEMICOLON .)
    BOOLEAN         reduce using rule 11 (var -> tipo ID SEMICOLON .)
    LCURLY          reduce using rule 11 (var -> tipo ID SEMICOLON .)
    IF              reduce using rule 11 (var -> tipo ID SEMICOLON .)
    WHILE           reduce using rule 11 (var -> tipo ID SEMICOLON .)
    PRINTLN         reduce using rule 11 (var -> tipo ID SEMICOLON .)
    RETURN          reduce using rule 11 (var -> tipo ID SEMICOLON .)


state 46

    (24) tipo -> INT LBRACKET RBRACKET .

    ID              reduce using rule 24 (tipo -> INT LBRACKET RBRACKET .)


state 47

    (2) main -> CLASS ID LCURLY PUBLIC STATIC VOID MAIN . LPAREN STRING LBRACKET RBRACKET ID RPAREN LCURLY cmd RCURLY RCURLY

    LPAREN          shift and go to state 52


state 48

    (3) main -> ID LCURLY PUBLIC STATIC VOID MAIN LPAREN . STRING LBRACKET RBRACKET ID RPAREN LCURLY cmd RCURLY RCURLY

    STRING          shift and go to state 53


state 49

    (6) classe -> CLASS ID EXTENDS ID LCURLY vars metodos . RCURLY
    (14) metodos -> metodos . metodo
    (15) metodo -> . PUBLIC tipo ID LPAREN params RPAREN LCURLY vars cmds RETURN exp SEMICOLON RCURLY
    (16) metodo -> . PUBLIC tipo ID LPAREN RPAREN LCURLY vars cmds RETURN exp SEMICOLON RCURLY
    (17) metodo -> . PUBLIC ID ID LPAREN params RPAREN LCURLY vars cmds RETURN exp SEMICOLON RCURLY
    (18) metodo -> . PUBLIC ID ID LPAREN RPAREN LCURLY vars cmds RETURN exp SEMICOLON RCURLY
    (19) metodo -> . empty
    (72) empty -> .

  ! shift/reduce conflict for PUBLIC resolved as shift
  ! shift/reduce conflict for RCURLY resolved as shift
    RCURLY          shift and go to state 54
    PUBLIC          shift and go to state 33
    ID              reduce using rule 72 (empty -> .)
    INT             reduce using rule 72 (empty -> .)
    BOOLEAN         reduce using rule 72 (empty -> .)
    RETURN          reduce using rule 72 (empty -> .)
    LCURLY          reduce using rule 72 (empty -> .)
    IF              reduce using rule 72 (empty -> .)
    WHILE           reduce using rule 72 (empty -> .)
    PRINTLN         reduce using rule 72 (empty -> .)
    ELSE            reduce using rule 72 (empty -> .)
    SEMICOLON       reduce using rule 72 (empty -> .)
    RPAREN          reduce using rule 72 (empty -> .)
    RBRACKET        reduce using rule 72 (empty -> .)
    AND             reduce using rule 72 (empty -> .)
    COMMA           reduce using rule 72 (empty -> .)

  ! PUBLIC          [ reduce using rule 72 (empty -> .) ]
  ! RCURLY          [ reduce using rule 72 (empty -> .) ]

    metodo                         shift and go to state 42
    empty                          shift and go to state 34

state 50

    (15) metodo -> PUBLIC tipo ID . LPAREN params RPAREN LCURLY vars cmds RETURN exp SEMICOLON RCURLY
    (16) metodo -> PUBLIC tipo ID . LPAREN RPAREN LCURLY vars cmds RETURN exp SEMICOLON RCURLY

    LPAREN          shift and go to state 55


state 51

    (17) metodo -> PUBLIC ID ID . LPAREN params RPAREN LCURLY vars cmds RETURN exp SEMICOLON RCURLY
    (18) metodo -> PUBLIC ID ID . LPAREN RPAREN LCURLY vars cmds RETURN exp SEMICOLON RCURLY

    LPAREN          shift and go to state 56


state 52

    (2) main -> CLASS ID LCURLY PUBLIC STATIC VOID MAIN LPAREN . STRING LBRACKET RBRACKET ID RPAREN LCURLY cmd RCURLY RCURLY

    STRING          shift and go to state 57


state 53

    (3) main -> ID LCURLY PUBLIC STATIC VOID MAIN LPAREN STRING . LBRACKET RBRACKET ID RPAREN LCURLY cmd RCURLY RCURLY

    LBRACKET        shift and go to state 58


state 54

    (6) classe -> CLASS ID EXTENDS ID LCURLY vars metodos RCURLY .

    $end            reduce using rule 6 (classe -> CLASS ID EXTENDS ID LCURLY vars metodos RCURLY .)
    CLASS           reduce using rule 6 (classe -> CLASS ID EXTENDS ID LCURLY vars metodos RCURLY .)


state 55

    (15) metodo -> PUBLIC tipo ID LPAREN . params RPAREN LCURLY vars cmds RETURN exp SEMICOLON RCURLY
    (16) metodo -> PUBLIC tipo ID LPAREN . RPAREN LCURLY vars cmds RETURN exp SEMICOLON RCURLY
    (20) params -> . tipo ID
    (21) params -> . params COMMA tipo ID
    (22) params -> . ID ID
    (23) params -> . params COMMA ID ID
    (24) tipo -> . INT LBRACKET RBRACKET
    (25) tipo -> . BOOLEAN
    (26) tipo -> . INT

    RPAREN          shift and go to state 62
    ID              shift and go to state 60
    INT             shift and go to state 24
    BOOLEAN         shift and go to state 25

    tipo                           shift and go to state 59
    params                         shift and go to state 61

state 56

    (17) metodo -> PUBLIC ID ID LPAREN . params RPAREN LCURLY vars cmds RETURN exp SEMICOLON RCURLY
    (18) metodo -> PUBLIC ID ID LPAREN . RPAREN LCURLY vars cmds RETURN exp SEMICOLON RCURLY
    (20) params -> . tipo ID
    (21) params -> . params COMMA tipo ID
    (22) params -> . ID ID
    (23) params -> . params COMMA ID ID
    (24) tipo -> . INT LBRACKET RBRACKET
    (25) tipo -> . BOOLEAN
    (26) tipo -> . INT

    RPAREN          shift and go to state 64
    ID              shift and go to state 60
    INT             shift and go to state 24
    BOOLEAN         shift and go to state 25

    params                         shift and go to state 63
    tipo                           shift and go to state 59

state 57

    (2) main -> CLASS ID LCURLY PUBLIC STATIC VOID MAIN LPAREN STRING . LBRACKET RBRACKET ID RPAREN LCURLY cmd RCURLY RCURLY

    LBRACKET        shift and go to state 65


state 58

    (3) main -> ID LCURLY PUBLIC STATIC VOID MAIN LPAREN STRING LBRACKET . RBRACKET ID RPAREN LCURLY cmd RCURLY RCURLY

    RBRACKET        shift and go to state 66


state 59

    (20) params -> tipo . ID

    ID              shift and go to state 67


state 60

    (22) params -> ID . ID

    ID              shift and go to state 68


state 61

    (15) metodo -> PUBLIC tipo ID LPAREN params . RPAREN LCURLY vars cmds RETURN exp SEMICOLON RCURLY
    (21) params -> params . COMMA tipo ID
    (23) params -> params . COMMA ID ID

    RPAREN          shift and go to state 69
    COMMA           shift and go to state 70


state 62

    (16) metodo -> PUBLIC tipo ID LPAREN RPAREN . LCURLY vars cmds RETURN exp SEMICOLON RCURLY

    LCURLY          shift and go to state 71


state 63

    (17) metodo -> PUBLIC ID ID LPAREN params . RPAREN LCURLY vars cmds RETURN exp SEMICOLON RCURLY
    (21) params -> params . COMMA tipo ID
    (23) params -> params . COMMA ID ID

    RPAREN          shift and go to state 72
    COMMA           shift and go to state 70


state 64

    (18) metodo -> PUBLIC ID ID LPAREN RPAREN . LCURLY vars cmds RETURN exp SEMICOLON RCURLY

    LCURLY          shift and go to state 73


state 65

    (2) main -> CLASS ID LCURLY PUBLIC STATIC VOID MAIN LPAREN STRING LBRACKET . RBRACKET ID RPAREN LCURLY cmd RCURLY RCURLY

    RBRACKET        shift and go to state 74


state 66

    (3) main -> ID LCURLY PUBLIC STATIC VOID MAIN LPAREN STRING LBRACKET RBRACKET . ID RPAREN LCURLY cmd RCURLY RCURLY

    ID              shift and go to state 75


state 67

    (20) params -> tipo ID .

    RPAREN          reduce using rule 20 (params -> tipo ID .)
    COMMA           reduce using rule 20 (params -> tipo ID .)


state 68

    (22) params -> ID ID .

    RPAREN          reduce using rule 22 (params -> ID ID .)
    COMMA           reduce using rule 22 (params -> ID ID .)


state 69

    (15) metodo -> PUBLIC tipo ID LPAREN params RPAREN . LCURLY vars cmds RETURN exp SEMICOLON RCURLY

    LCURLY          shift and go to state 76


state 70

    (21) params -> params COMMA . tipo ID
    (23) params -> params COMMA . ID ID
    (24) tipo -> . INT LBRACKET RBRACKET
    (25) tipo -> . BOOLEAN
    (26) tipo -> . INT

    ID              shift and go to state 78
    INT             shift and go to state 24
    BOOLEAN         shift and go to state 25

    tipo                           shift and go to state 77

state 71

    (16) metodo -> PUBLIC tipo ID LPAREN RPAREN LCURLY . vars cmds RETURN exp SEMICOLON RCURLY
    (8) vars -> . var
    (9) vars -> . vars var
    (10) vars -> . empty
    (11) var -> . tipo ID SEMICOLON
    (12) var -> . ID ID SEMICOLON
    (72) empty -> .
    (24) tipo -> . INT LBRACKET RBRACKET
    (25) tipo -> . BOOLEAN
    (26) tipo -> . INT

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
    ID              shift and go to state 19
    PUBLIC          reduce using rule 72 (empty -> .)
    RCURLY          reduce using rule 72 (empty -> .)
    RETURN          reduce using rule 72 (empty -> .)
    LCURLY          reduce using rule 72 (empty -> .)
    IF              reduce using rule 72 (empty -> .)
    WHILE           reduce using rule 72 (empty -> .)
    PRINTLN         reduce using rule 72 (empty -> .)
    ELSE            reduce using rule 72 (empty -> .)
    SEMICOLON       reduce using rule 72 (empty -> .)
    RPAREN          reduce using rule 72 (empty -> .)
    RBRACKET        reduce using rule 72 (empty -> .)
    AND             reduce using rule 72 (empty -> .)
    COMMA           reduce using rule 72 (empty -> .)
    INT             shift and go to state 24
    BOOLEAN         shift and go to state 25

  ! ID              [ reduce using rule 72 (empty -> .) ]
  ! INT             [ reduce using rule 72 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 72 (empty -> .) ]

    tipo                           shift and go to state 23
    vars                           shift and go to state 79
    var                            shift and go to state 21
    empty                          shift and go to state 22

state 72

    (17) metodo -> PUBLIC ID ID LPAREN params RPAREN . LCURLY vars cmds RETURN exp SEMICOLON RCURLY

    LCURLY          shift and go to state 80


state 73

    (18) metodo -> PUBLIC ID ID LPAREN RPAREN LCURLY . vars cmds RETURN exp SEMICOLON RCURLY
    (8) vars -> . var
    (9) vars -> . vars var
    (10) vars -> . empty
    (11) var -> . tipo ID SEMICOLON
    (12) var -> . ID ID SEMICOLON
    (72) empty -> .
    (24) tipo -> . INT LBRACKET RBRACKET
    (25) tipo -> . BOOLEAN
    (26) tipo -> . INT

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
    ID              shift and go to state 19
    PUBLIC          reduce using rule 72 (empty -> .)
    RCURLY          reduce using rule 72 (empty -> .)
    RETURN          reduce using rule 72 (empty -> .)
    LCURLY          reduce using rule 72 (empty -> .)
    IF              reduce using rule 72 (empty -> .)
    WHILE           reduce using rule 72 (empty -> .)
    PRINTLN         reduce using rule 72 (empty -> .)
    ELSE            reduce using rule 72 (empty -> .)
    SEMICOLON       reduce using rule 72 (empty -> .)
    RPAREN          reduce using rule 72 (empty -> .)
    RBRACKET        reduce using rule 72 (empty -> .)
    AND             reduce using rule 72 (empty -> .)
    COMMA           reduce using rule 72 (empty -> .)
    INT             shift and go to state 24
    BOOLEAN         shift and go to state 25

  ! ID              [ reduce using rule 72 (empty -> .) ]
  ! INT             [ reduce using rule 72 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 72 (empty -> .) ]

    vars                           shift and go to state 81
    var                            shift and go to state 21
    empty                          shift and go to state 22
    tipo                           shift and go to state 23

state 74

    (2) main -> CLASS ID LCURLY PUBLIC STATIC VOID MAIN LPAREN STRING LBRACKET RBRACKET . ID RPAREN LCURLY cmd RCURLY RCURLY

    ID              shift and go to state 82


state 75

    (3) main -> ID LCURLY PUBLIC STATIC VOID MAIN LPAREN STRING LBRACKET RBRACKET ID . RPAREN LCURLY cmd RCURLY RCURLY

    RPAREN          shift and go to state 83


state 76

    (15) metodo -> PUBLIC tipo ID LPAREN params RPAREN LCURLY . vars cmds RETURN exp SEMICOLON RCURLY
    (8) vars -> . var
    (9) vars -> . vars var
    (10) vars -> . empty
    (11) var -> . tipo ID SEMICOLON
    (12) var -> . ID ID SEMICOLON
    (72) empty -> .
    (24) tipo -> . INT LBRACKET RBRACKET
    (25) tipo -> . BOOLEAN
    (26) tipo -> . INT

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
    ID              shift and go to state 19
    PUBLIC          reduce using rule 72 (empty -> .)
    RCURLY          reduce using rule 72 (empty -> .)
    RETURN          reduce using rule 72 (empty -> .)
    LCURLY          reduce using rule 72 (empty -> .)
    IF              reduce using rule 72 (empty -> .)
    WHILE           reduce using rule 72 (empty -> .)
    PRINTLN         reduce using rule 72 (empty -> .)
    ELSE            reduce using rule 72 (empty -> .)
    SEMICOLON       reduce using rule 72 (empty -> .)
    RPAREN          reduce using rule 72 (empty -> .)
    RBRACKET        reduce using rule 72 (empty -> .)
    AND             reduce using rule 72 (empty -> .)
    COMMA           reduce using rule 72 (empty -> .)
    INT             shift and go to state 24
    BOOLEAN         shift and go to state 25

  ! ID              [ reduce using rule 72 (empty -> .) ]
  ! INT             [ reduce using rule 72 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 72 (empty -> .) ]

    tipo                           shift and go to state 23
    vars                           shift and go to state 84
    var                            shift and go to state 21
    empty                          shift and go to state 22

state 77

    (21) params -> params COMMA tipo . ID

    ID              shift and go to state 85


state 78

    (23) params -> params COMMA ID . ID

    ID              shift and go to state 86


state 79

    (16) metodo -> PUBLIC tipo ID LPAREN RPAREN LCURLY vars . cmds RETURN exp SEMICOLON RCURLY
    (9) vars -> vars . var
    (27) cmds -> . cmd
    (28) cmds -> . cmds cmd
    (11) var -> . tipo ID SEMICOLON
    (12) var -> . ID ID SEMICOLON
    (29) cmd -> . LCURLY cmds RCURLY
    (30) cmd -> . IF LPAREN exp RPAREN cmd
    (31) cmd -> . IF LPAREN exp RPAREN cmd ELSE cmd
    (32) cmd -> . WHILE LPAREN exp RPAREN cmd
    (33) cmd -> . PRINTLN LPAREN exp RPAREN SEMICOLON
    (34) cmd -> . ID ASSIGN exp SEMICOLON
    (35) cmd -> . ID LBRACKET exp RBRACKET ASSIGN exp SEMICOLON
    (36) cmd -> . empty
    (24) tipo -> . INT LBRACKET RBRACKET
    (25) tipo -> . BOOLEAN
    (26) tipo -> . INT
    (72) empty -> .

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for LCURLY resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for PRINTLN resolved as shift
    ID              shift and go to state 87
    LCURLY          shift and go to state 88
    IF              shift and go to state 91
    WHILE           shift and go to state 92
    PRINTLN         shift and go to state 93
    INT             shift and go to state 24
    BOOLEAN         shift and go to state 25
    PUBLIC          reduce using rule 72 (empty -> .)
    RCURLY          reduce using rule 72 (empty -> .)
    RETURN          reduce using rule 72 (empty -> .)
    ELSE            reduce using rule 72 (empty -> .)
    SEMICOLON       reduce using rule 72 (empty -> .)
    RPAREN          reduce using rule 72 (empty -> .)
    RBRACKET        reduce using rule 72 (empty -> .)
    AND             reduce using rule 72 (empty -> .)
    COMMA           reduce using rule 72 (empty -> .)

  ! ID              [ reduce using rule 72 (empty -> .) ]
  ! INT             [ reduce using rule 72 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 72 (empty -> .) ]
  ! LCURLY          [ reduce using rule 72 (empty -> .) ]
  ! IF              [ reduce using rule 72 (empty -> .) ]
  ! WHILE           [ reduce using rule 72 (empty -> .) ]
  ! PRINTLN         [ reduce using rule 72 (empty -> .) ]

    tipo                           shift and go to state 23
    cmds                           shift and go to state 89
    var                            shift and go to state 31
    cmd                            shift and go to state 90
    empty                          shift and go to state 94

state 80

    (17) metodo -> PUBLIC ID ID LPAREN params RPAREN LCURLY . vars cmds RETURN exp SEMICOLON RCURLY
    (8) vars -> . var
    (9) vars -> . vars var
    (10) vars -> . empty
    (11) var -> . tipo ID SEMICOLON
    (12) var -> . ID ID SEMICOLON
    (72) empty -> .
    (24) tipo -> . INT LBRACKET RBRACKET
    (25) tipo -> . BOOLEAN
    (26) tipo -> . INT

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
    ID              shift and go to state 19
    PUBLIC          reduce using rule 72 (empty -> .)
    RCURLY          reduce using rule 72 (empty -> .)
    RETURN          reduce using rule 72 (empty -> .)
    LCURLY          reduce using rule 72 (empty -> .)
    IF              reduce using rule 72 (empty -> .)
    WHILE           reduce using rule 72 (empty -> .)
    PRINTLN         reduce using rule 72 (empty -> .)
    ELSE            reduce using rule 72 (empty -> .)
    SEMICOLON       reduce using rule 72 (empty -> .)
    RPAREN          reduce using rule 72 (empty -> .)
    RBRACKET        reduce using rule 72 (empty -> .)
    AND             reduce using rule 72 (empty -> .)
    COMMA           reduce using rule 72 (empty -> .)
    INT             shift and go to state 24
    BOOLEAN         shift and go to state 25

  ! ID              [ reduce using rule 72 (empty -> .) ]
  ! INT             [ reduce using rule 72 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 72 (empty -> .) ]

    vars                           shift and go to state 95
    var                            shift and go to state 21
    empty                          shift and go to state 22
    tipo                           shift and go to state 23

state 81

    (18) metodo -> PUBLIC ID ID LPAREN RPAREN LCURLY vars . cmds RETURN exp SEMICOLON RCURLY
    (9) vars -> vars . var
    (27) cmds -> . cmd
    (28) cmds -> . cmds cmd
    (11) var -> . tipo ID SEMICOLON
    (12) var -> . ID ID SEMICOLON
    (29) cmd -> . LCURLY cmds RCURLY
    (30) cmd -> . IF LPAREN exp RPAREN cmd
    (31) cmd -> . IF LPAREN exp RPAREN cmd ELSE cmd
    (32) cmd -> . WHILE LPAREN exp RPAREN cmd
    (33) cmd -> . PRINTLN LPAREN exp RPAREN SEMICOLON
    (34) cmd -> . ID ASSIGN exp SEMICOLON
    (35) cmd -> . ID LBRACKET exp RBRACKET ASSIGN exp SEMICOLON
    (36) cmd -> . empty
    (24) tipo -> . INT LBRACKET RBRACKET
    (25) tipo -> . BOOLEAN
    (26) tipo -> . INT
    (72) empty -> .

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for LCURLY resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for PRINTLN resolved as shift
    ID              shift and go to state 87
    LCURLY          shift and go to state 88
    IF              shift and go to state 91
    WHILE           shift and go to state 92
    PRINTLN         shift and go to state 93
    INT             shift and go to state 24
    BOOLEAN         shift and go to state 25
    PUBLIC          reduce using rule 72 (empty -> .)
    RCURLY          reduce using rule 72 (empty -> .)
    RETURN          reduce using rule 72 (empty -> .)
    ELSE            reduce using rule 72 (empty -> .)
    SEMICOLON       reduce using rule 72 (empty -> .)
    RPAREN          reduce using rule 72 (empty -> .)
    RBRACKET        reduce using rule 72 (empty -> .)
    AND             reduce using rule 72 (empty -> .)
    COMMA           reduce using rule 72 (empty -> .)

  ! ID              [ reduce using rule 72 (empty -> .) ]
  ! INT             [ reduce using rule 72 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 72 (empty -> .) ]
  ! LCURLY          [ reduce using rule 72 (empty -> .) ]
  ! IF              [ reduce using rule 72 (empty -> .) ]
  ! WHILE           [ reduce using rule 72 (empty -> .) ]
  ! PRINTLN         [ reduce using rule 72 (empty -> .) ]

    cmds                           shift and go to state 96
    var                            shift and go to state 31
    cmd                            shift and go to state 90
    tipo                           shift and go to state 23
    empty                          shift and go to state 94

state 82

    (2) main -> CLASS ID LCURLY PUBLIC STATIC VOID MAIN LPAREN STRING LBRACKET RBRACKET ID . RPAREN LCURLY cmd RCURLY RCURLY

    RPAREN          shift and go to state 97


state 83

    (3) main -> ID LCURLY PUBLIC STATIC VOID MAIN LPAREN STRING LBRACKET RBRACKET ID RPAREN . LCURLY cmd RCURLY RCURLY

    LCURLY          shift and go to state 98


state 84

    (15) metodo -> PUBLIC tipo ID LPAREN params RPAREN LCURLY vars . cmds RETURN exp SEMICOLON RCURLY
    (9) vars -> vars . var
    (27) cmds -> . cmd
    (28) cmds -> . cmds cmd
    (11) var -> . tipo ID SEMICOLON
    (12) var -> . ID ID SEMICOLON
    (29) cmd -> . LCURLY cmds RCURLY
    (30) cmd -> . IF LPAREN exp RPAREN cmd
    (31) cmd -> . IF LPAREN exp RPAREN cmd ELSE cmd
    (32) cmd -> . WHILE LPAREN exp RPAREN cmd
    (33) cmd -> . PRINTLN LPAREN exp RPAREN SEMICOLON
    (34) cmd -> . ID ASSIGN exp SEMICOLON
    (35) cmd -> . ID LBRACKET exp RBRACKET ASSIGN exp SEMICOLON
    (36) cmd -> . empty
    (24) tipo -> . INT LBRACKET RBRACKET
    (25) tipo -> . BOOLEAN
    (26) tipo -> . INT
    (72) empty -> .

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for LCURLY resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for PRINTLN resolved as shift
    ID              shift and go to state 87
    LCURLY          shift and go to state 88
    IF              shift and go to state 91
    WHILE           shift and go to state 92
    PRINTLN         shift and go to state 93
    INT             shift and go to state 24
    BOOLEAN         shift and go to state 25
    PUBLIC          reduce using rule 72 (empty -> .)
    RCURLY          reduce using rule 72 (empty -> .)
    RETURN          reduce using rule 72 (empty -> .)
    ELSE            reduce using rule 72 (empty -> .)
    SEMICOLON       reduce using rule 72 (empty -> .)
    RPAREN          reduce using rule 72 (empty -> .)
    RBRACKET        reduce using rule 72 (empty -> .)
    AND             reduce using rule 72 (empty -> .)
    COMMA           reduce using rule 72 (empty -> .)

  ! ID              [ reduce using rule 72 (empty -> .) ]
  ! INT             [ reduce using rule 72 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 72 (empty -> .) ]
  ! LCURLY          [ reduce using rule 72 (empty -> .) ]
  ! IF              [ reduce using rule 72 (empty -> .) ]
  ! WHILE           [ reduce using rule 72 (empty -> .) ]
  ! PRINTLN         [ reduce using rule 72 (empty -> .) ]

    tipo                           shift and go to state 23
    cmds                           shift and go to state 99
    var                            shift and go to state 31
    cmd                            shift and go to state 90
    empty                          shift and go to state 94

state 85

    (21) params -> params COMMA tipo ID .

    RPAREN          reduce using rule 21 (params -> params COMMA tipo ID .)
    COMMA           reduce using rule 21 (params -> params COMMA tipo ID .)


state 86

    (23) params -> params COMMA ID ID .

    RPAREN          reduce using rule 23 (params -> params COMMA ID ID .)
    COMMA           reduce using rule 23 (params -> params COMMA ID ID .)


state 87

    (12) var -> ID . ID SEMICOLON
    (34) cmd -> ID . ASSIGN exp SEMICOLON
    (35) cmd -> ID . LBRACKET exp RBRACKET ASSIGN exp SEMICOLON

    ID              shift and go to state 29
    ASSIGN          shift and go to state 100
    LBRACKET        shift and go to state 101


state 88

    (29) cmd -> LCURLY . cmds RCURLY
    (27) cmds -> . cmd
    (28) cmds -> . cmds cmd
    (29) cmd -> . LCURLY cmds RCURLY
    (30) cmd -> . IF LPAREN exp RPAREN cmd
    (31) cmd -> . IF LPAREN exp RPAREN cmd ELSE cmd
    (32) cmd -> . WHILE LPAREN exp RPAREN cmd
    (33) cmd -> . PRINTLN LPAREN exp RPAREN SEMICOLON
    (34) cmd -> . ID ASSIGN exp SEMICOLON
    (35) cmd -> . ID LBRACKET exp RBRACKET ASSIGN exp SEMICOLON
    (36) cmd -> . empty
    (72) empty -> .

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for LCURLY resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for PRINTLN resolved as shift
    LCURLY          shift and go to state 88
    IF              shift and go to state 91
    WHILE           shift and go to state 92
    PRINTLN         shift and go to state 93
    ID              shift and go to state 103
    PUBLIC          reduce using rule 72 (empty -> .)
    RCURLY          reduce using rule 72 (empty -> .)
    INT             reduce using rule 72 (empty -> .)
    BOOLEAN         reduce using rule 72 (empty -> .)
    RETURN          reduce using rule 72 (empty -> .)
    ELSE            reduce using rule 72 (empty -> .)
    SEMICOLON       reduce using rule 72 (empty -> .)
    RPAREN          reduce using rule 72 (empty -> .)
    RBRACKET        reduce using rule 72 (empty -> .)
    AND             reduce using rule 72 (empty -> .)
    COMMA           reduce using rule 72 (empty -> .)

  ! ID              [ reduce using rule 72 (empty -> .) ]
  ! LCURLY          [ reduce using rule 72 (empty -> .) ]
  ! IF              [ reduce using rule 72 (empty -> .) ]
  ! WHILE           [ reduce using rule 72 (empty -> .) ]
  ! PRINTLN         [ reduce using rule 72 (empty -> .) ]

    cmds                           shift and go to state 102
    cmd                            shift and go to state 90
    empty                          shift and go to state 94

state 89

    (16) metodo -> PUBLIC tipo ID LPAREN RPAREN LCURLY vars cmds . RETURN exp SEMICOLON RCURLY
    (28) cmds -> cmds . cmd
    (29) cmd -> . LCURLY cmds RCURLY
    (30) cmd -> . IF LPAREN exp RPAREN cmd
    (31) cmd -> . IF LPAREN exp RPAREN cmd ELSE cmd
    (32) cmd -> . WHILE LPAREN exp RPAREN cmd
    (33) cmd -> . PRINTLN LPAREN exp RPAREN SEMICOLON
    (34) cmd -> . ID ASSIGN exp SEMICOLON
    (35) cmd -> . ID LBRACKET exp RBRACKET ASSIGN exp SEMICOLON
    (36) cmd -> . empty
    (72) empty -> .

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for LCURLY resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for PRINTLN resolved as shift
    RETURN          shift and go to state 104
    LCURLY          shift and go to state 88
    IF              shift and go to state 91
    WHILE           shift and go to state 92
    PRINTLN         shift and go to state 93
    ID              shift and go to state 103
    PUBLIC          reduce using rule 72 (empty -> .)
    RCURLY          reduce using rule 72 (empty -> .)
    INT             reduce using rule 72 (empty -> .)
    BOOLEAN         reduce using rule 72 (empty -> .)
    ELSE            reduce using rule 72 (empty -> .)
    SEMICOLON       reduce using rule 72 (empty -> .)
    RPAREN          reduce using rule 72 (empty -> .)
    RBRACKET        reduce using rule 72 (empty -> .)
    AND             reduce using rule 72 (empty -> .)
    COMMA           reduce using rule 72 (empty -> .)

  ! ID              [ reduce using rule 72 (empty -> .) ]
  ! RETURN          [ reduce using rule 72 (empty -> .) ]
  ! LCURLY          [ reduce using rule 72 (empty -> .) ]
  ! IF              [ reduce using rule 72 (empty -> .) ]
  ! WHILE           [ reduce using rule 72 (empty -> .) ]
  ! PRINTLN         [ reduce using rule 72 (empty -> .) ]

    cmd                            shift and go to state 105
    empty                          shift and go to state 94

state 90

    (27) cmds -> cmd .

    RETURN          reduce using rule 27 (cmds -> cmd .)
    LCURLY          reduce using rule 27 (cmds -> cmd .)
    IF              reduce using rule 27 (cmds -> cmd .)
    WHILE           reduce using rule 27 (cmds -> cmd .)
    PRINTLN         reduce using rule 27 (cmds -> cmd .)
    ID              reduce using rule 27 (cmds -> cmd .)
    RCURLY          reduce using rule 27 (cmds -> cmd .)


state 91

    (30) cmd -> IF . LPAREN exp RPAREN cmd
    (31) cmd -> IF . LPAREN exp RPAREN cmd ELSE cmd

    LPAREN          shift and go to state 106


state 92

    (32) cmd -> WHILE . LPAREN exp RPAREN cmd

    LPAREN          shift and go to state 107


state 93

    (33) cmd -> PRINTLN . LPAREN exp RPAREN SEMICOLON

    LPAREN          shift and go to state 108


state 94

    (36) cmd -> empty .

    RCURLY          reduce using rule 36 (cmd -> empty .)
    RETURN          reduce using rule 36 (cmd -> empty .)
    LCURLY          reduce using rule 36 (cmd -> empty .)
    IF              reduce using rule 36 (cmd -> empty .)
    WHILE           reduce using rule 36 (cmd -> empty .)
    PRINTLN         reduce using rule 36 (cmd -> empty .)
    ID              reduce using rule 36 (cmd -> empty .)
    ELSE            reduce using rule 36 (cmd -> empty .)


state 95

    (17) metodo -> PUBLIC ID ID LPAREN params RPAREN LCURLY vars . cmds RETURN exp SEMICOLON RCURLY
    (9) vars -> vars . var
    (27) cmds -> . cmd
    (28) cmds -> . cmds cmd
    (11) var -> . tipo ID SEMICOLON
    (12) var -> . ID ID SEMICOLON
    (29) cmd -> . LCURLY cmds RCURLY
    (30) cmd -> . IF LPAREN exp RPAREN cmd
    (31) cmd -> . IF LPAREN exp RPAREN cmd ELSE cmd
    (32) cmd -> . WHILE LPAREN exp RPAREN cmd
    (33) cmd -> . PRINTLN LPAREN exp RPAREN SEMICOLON
    (34) cmd -> . ID ASSIGN exp SEMICOLON
    (35) cmd -> . ID LBRACKET exp RBRACKET ASSIGN exp SEMICOLON
    (36) cmd -> . empty
    (24) tipo -> . INT LBRACKET RBRACKET
    (25) tipo -> . BOOLEAN
    (26) tipo -> . INT
    (72) empty -> .

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for LCURLY resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for PRINTLN resolved as shift
    ID              shift and go to state 87
    LCURLY          shift and go to state 88
    IF              shift and go to state 91
    WHILE           shift and go to state 92
    PRINTLN         shift and go to state 93
    INT             shift and go to state 24
    BOOLEAN         shift and go to state 25
    PUBLIC          reduce using rule 72 (empty -> .)
    RCURLY          reduce using rule 72 (empty -> .)
    RETURN          reduce using rule 72 (empty -> .)
    ELSE            reduce using rule 72 (empty -> .)
    SEMICOLON       reduce using rule 72 (empty -> .)
    RPAREN          reduce using rule 72 (empty -> .)
    RBRACKET        reduce using rule 72 (empty -> .)
    AND             reduce using rule 72 (empty -> .)
    COMMA           reduce using rule 72 (empty -> .)

  ! ID              [ reduce using rule 72 (empty -> .) ]
  ! INT             [ reduce using rule 72 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 72 (empty -> .) ]
  ! LCURLY          [ reduce using rule 72 (empty -> .) ]
  ! IF              [ reduce using rule 72 (empty -> .) ]
  ! WHILE           [ reduce using rule 72 (empty -> .) ]
  ! PRINTLN         [ reduce using rule 72 (empty -> .) ]

    cmds                           shift and go to state 109
    var                            shift and go to state 31
    cmd                            shift and go to state 90
    tipo                           shift and go to state 23
    empty                          shift and go to state 94

state 96

    (18) metodo -> PUBLIC ID ID LPAREN RPAREN LCURLY vars cmds . RETURN exp SEMICOLON RCURLY
    (28) cmds -> cmds . cmd
    (29) cmd -> . LCURLY cmds RCURLY
    (30) cmd -> . IF LPAREN exp RPAREN cmd
    (31) cmd -> . IF LPAREN exp RPAREN cmd ELSE cmd
    (32) cmd -> . WHILE LPAREN exp RPAREN cmd
    (33) cmd -> . PRINTLN LPAREN exp RPAREN SEMICOLON
    (34) cmd -> . ID ASSIGN exp SEMICOLON
    (35) cmd -> . ID LBRACKET exp RBRACKET ASSIGN exp SEMICOLON
    (36) cmd -> . empty
    (72) empty -> .

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for LCURLY resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for PRINTLN resolved as shift
    RETURN          shift and go to state 110
    LCURLY          shift and go to state 88
    IF              shift and go to state 91
    WHILE           shift and go to state 92
    PRINTLN         shift and go to state 93
    ID              shift and go to state 103
    PUBLIC          reduce using rule 72 (empty -> .)
    RCURLY          reduce using rule 72 (empty -> .)
    INT             reduce using rule 72 (empty -> .)
    BOOLEAN         reduce using rule 72 (empty -> .)
    ELSE            reduce using rule 72 (empty -> .)
    SEMICOLON       reduce using rule 72 (empty -> .)
    RPAREN          reduce using rule 72 (empty -> .)
    RBRACKET        reduce using rule 72 (empty -> .)
    AND             reduce using rule 72 (empty -> .)
    COMMA           reduce using rule 72 (empty -> .)

  ! ID              [ reduce using rule 72 (empty -> .) ]
  ! RETURN          [ reduce using rule 72 (empty -> .) ]
  ! LCURLY          [ reduce using rule 72 (empty -> .) ]
  ! IF              [ reduce using rule 72 (empty -> .) ]
  ! WHILE           [ reduce using rule 72 (empty -> .) ]
  ! PRINTLN         [ reduce using rule 72 (empty -> .) ]

    cmd                            shift and go to state 105
    empty                          shift and go to state 94

state 97

    (2) main -> CLASS ID LCURLY PUBLIC STATIC VOID MAIN LPAREN STRING LBRACKET RBRACKET ID RPAREN . LCURLY cmd RCURLY RCURLY

    LCURLY          shift and go to state 111


state 98

    (3) main -> ID LCURLY PUBLIC STATIC VOID MAIN LPAREN STRING LBRACKET RBRACKET ID RPAREN LCURLY . cmd RCURLY RCURLY
    (29) cmd -> . LCURLY cmds RCURLY
    (30) cmd -> . IF LPAREN exp RPAREN cmd
    (31) cmd -> . IF LPAREN exp RPAREN cmd ELSE cmd
    (32) cmd -> . WHILE LPAREN exp RPAREN cmd
    (33) cmd -> . PRINTLN LPAREN exp RPAREN SEMICOLON
    (34) cmd -> . ID ASSIGN exp SEMICOLON
    (35) cmd -> . ID LBRACKET exp RBRACKET ASSIGN exp SEMICOLON
    (36) cmd -> . empty
    (72) empty -> .

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for LCURLY resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for PRINTLN resolved as shift
    LCURLY          shift and go to state 88
    IF              shift and go to state 91
    WHILE           shift and go to state 92
    PRINTLN         shift and go to state 93
    ID              shift and go to state 103
    PUBLIC          reduce using rule 72 (empty -> .)
    RCURLY          reduce using rule 72 (empty -> .)
    INT             reduce using rule 72 (empty -> .)
    BOOLEAN         reduce using rule 72 (empty -> .)
    RETURN          reduce using rule 72 (empty -> .)
    ELSE            reduce using rule 72 (empty -> .)
    SEMICOLON       reduce using rule 72 (empty -> .)
    RPAREN          reduce using rule 72 (empty -> .)
    RBRACKET        reduce using rule 72 (empty -> .)
    AND             reduce using rule 72 (empty -> .)
    COMMA           reduce using rule 72 (empty -> .)

  ! ID              [ reduce using rule 72 (empty -> .) ]
  ! LCURLY          [ reduce using rule 72 (empty -> .) ]
  ! IF              [ reduce using rule 72 (empty -> .) ]
  ! WHILE           [ reduce using rule 72 (empty -> .) ]
  ! PRINTLN         [ reduce using rule 72 (empty -> .) ]

    cmd                            shift and go to state 112
    empty                          shift and go to state 94

state 99

    (15) metodo -> PUBLIC tipo ID LPAREN params RPAREN LCURLY vars cmds . RETURN exp SEMICOLON RCURLY
    (28) cmds -> cmds . cmd
    (29) cmd -> . LCURLY cmds RCURLY
    (30) cmd -> . IF LPAREN exp RPAREN cmd
    (31) cmd -> . IF LPAREN exp RPAREN cmd ELSE cmd
    (32) cmd -> . WHILE LPAREN exp RPAREN cmd
    (33) cmd -> . PRINTLN LPAREN exp RPAREN SEMICOLON
    (34) cmd -> . ID ASSIGN exp SEMICOLON
    (35) cmd -> . ID LBRACKET exp RBRACKET ASSIGN exp SEMICOLON
    (36) cmd -> . empty
    (72) empty -> .

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for LCURLY resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for PRINTLN resolved as shift
    RETURN          shift and go to state 113
    LCURLY          shift and go to state 88
    IF              shift and go to state 91
    WHILE           shift and go to state 92
    PRINTLN         shift and go to state 93
    ID              shift and go to state 103
    PUBLIC          reduce using rule 72 (empty -> .)
    RCURLY          reduce using rule 72 (empty -> .)
    INT             reduce using rule 72 (empty -> .)
    BOOLEAN         reduce using rule 72 (empty -> .)
    ELSE            reduce using rule 72 (empty -> .)
    SEMICOLON       reduce using rule 72 (empty -> .)
    RPAREN          reduce using rule 72 (empty -> .)
    RBRACKET        reduce using rule 72 (empty -> .)
    AND             reduce using rule 72 (empty -> .)
    COMMA           reduce using rule 72 (empty -> .)

  ! ID              [ reduce using rule 72 (empty -> .) ]
  ! RETURN          [ reduce using rule 72 (empty -> .) ]
  ! LCURLY          [ reduce using rule 72 (empty -> .) ]
  ! IF              [ reduce using rule 72 (empty -> .) ]
  ! WHILE           [ reduce using rule 72 (empty -> .) ]
  ! PRINTLN         [ reduce using rule 72 (empty -> .) ]

    cmd                            shift and go to state 105
    empty                          shift and go to state 94

state 100

    (34) cmd -> ID ASSIGN . exp SEMICOLON
    (37) exp -> . exp AND rexp
    (38) exp -> . rexp
    (39) exp -> . empty
    (40) rexp -> . rexp LTHAN aexp
    (41) rexp -> . rexp EQUALS aexp
    (42) rexp -> . rexp DIFFERENT aexp
    (43) rexp -> . aexp
    (72) empty -> .
    (44) aexp -> . aexp PLUS mexp
    (45) aexp -> . aexp MINUS mexp
    (46) aexp -> . mexp
    (47) mexp -> . mexp TIMES sexp
    (48) mexp -> . sexp
    (49) sexp -> . NOT sexp
    (50) sexp -> . MINUS sexp
    (51) sexp -> . TRUE
    (52) sexp -> . FALSE
    (53) sexp -> . NUMBER
    (54) sexp -> . NULL
    (55) sexp -> . NEW INT LBRACKET exp RBRACKET
    (56) sexp -> . pexp DOT LENGTH
    (57) sexp -> . ID DOT LENGTH
    (58) sexp -> . pexp LBRACKET exp RBRACKET
    (59) sexp -> . ID LBRACKET exp RBRACKET
    (60) sexp -> . ID
    (61) pexp -> . THIS
    (62) pexp -> . NEW ID LPAREN RPAREN
    (63) pexp -> . LPAREN exp RPAREN
    (64) pexp -> . pexp DOT ID
    (65) pexp -> . ID DOT ID
    (66) pexp -> . pexp DOT ID LPAREN exps RPAREN
    (67) pexp -> . pexp DOT ID LPAREN RPAREN
    (68) pexp -> . ID DOT ID LPAREN exps RPAREN
    (69) pexp -> . ID DOT ID LPAREN RPAREN

  ! shift/reduce conflict for ID resolved as shift
    PUBLIC          reduce using rule 72 (empty -> .)
    RCURLY          reduce using rule 72 (empty -> .)
    INT             reduce using rule 72 (empty -> .)
    BOOLEAN         reduce using rule 72 (empty -> .)
    RETURN          reduce using rule 72 (empty -> .)
    LCURLY          reduce using rule 72 (empty -> .)
    IF              reduce using rule 72 (empty -> .)
    WHILE           reduce using rule 72 (empty -> .)
    PRINTLN         reduce using rule 72 (empty -> .)
    ELSE            reduce using rule 72 (empty -> .)
    SEMICOLON       reduce using rule 72 (empty -> .)
    RPAREN          reduce using rule 72 (empty -> .)
    RBRACKET        reduce using rule 72 (empty -> .)
    AND             reduce using rule 72 (empty -> .)
    COMMA           reduce using rule 72 (empty -> .)
    NOT             shift and go to state 122
    MINUS           shift and go to state 120
    TRUE            shift and go to state 123
    FALSE           shift and go to state 124
    NUMBER          shift and go to state 125
    NULL            shift and go to state 126
    NEW             shift and go to state 127
    ID              shift and go to state 114
    THIS            shift and go to state 129
    LPAREN          shift and go to state 130

  ! ID              [ reduce using rule 72 (empty -> .) ]

    exp                            shift and go to state 115
    rexp                           shift and go to state 116
    empty                          shift and go to state 117
    aexp                           shift and go to state 118
    mexp                           shift and go to state 119
    sexp                           shift and go to state 121
    pexp                           shift and go to state 128

state 101

    (35) cmd -> ID LBRACKET . exp RBRACKET ASSIGN exp SEMICOLON
    (37) exp -> . exp AND rexp
    (38) exp -> . rexp
    (39) exp -> . empty
    (40) rexp -> . rexp LTHAN aexp
    (41) rexp -> . rexp EQUALS aexp
    (42) rexp -> . rexp DIFFERENT aexp
    (43) rexp -> . aexp
    (72) empty -> .
    (44) aexp -> . aexp PLUS mexp
    (45) aexp -> . aexp MINUS mexp
    (46) aexp -> . mexp
    (47) mexp -> . mexp TIMES sexp
    (48) mexp -> . sexp
    (49) sexp -> . NOT sexp
    (50) sexp -> . MINUS sexp
    (51) sexp -> . TRUE
    (52) sexp -> . FALSE
    (53) sexp -> . NUMBER
    (54) sexp -> . NULL
    (55) sexp -> . NEW INT LBRACKET exp RBRACKET
    (56) sexp -> . pexp DOT LENGTH
    (57) sexp -> . ID DOT LENGTH
    (58) sexp -> . pexp LBRACKET exp RBRACKET
    (59) sexp -> . ID LBRACKET exp RBRACKET
    (60) sexp -> . ID
    (61) pexp -> . THIS
    (62) pexp -> . NEW ID LPAREN RPAREN
    (63) pexp -> . LPAREN exp RPAREN
    (64) pexp -> . pexp DOT ID
    (65) pexp -> . ID DOT ID
    (66) pexp -> . pexp DOT ID LPAREN exps RPAREN
    (67) pexp -> . pexp DOT ID LPAREN RPAREN
    (68) pexp -> . ID DOT ID LPAREN exps RPAREN
    (69) pexp -> . ID DOT ID LPAREN RPAREN

  ! shift/reduce conflict for ID resolved as shift
    PUBLIC          reduce using rule 72 (empty -> .)
    RCURLY          reduce using rule 72 (empty -> .)
    INT             reduce using rule 72 (empty -> .)
    BOOLEAN         reduce using rule 72 (empty -> .)
    RETURN          reduce using rule 72 (empty -> .)
    LCURLY          reduce using rule 72 (empty -> .)
    IF              reduce using rule 72 (empty -> .)
    WHILE           reduce using rule 72 (empty -> .)
    PRINTLN         reduce using rule 72 (empty -> .)
    ELSE            reduce using rule 72 (empty -> .)
    SEMICOLON       reduce using rule 72 (empty -> .)
    RPAREN          reduce using rule 72 (empty -> .)
    RBRACKET        reduce using rule 72 (empty -> .)
    AND             reduce using rule 72 (empty -> .)
    COMMA           reduce using rule 72 (empty -> .)
    NOT             shift and go to state 122
    MINUS           shift and go to state 120
    TRUE            shift and go to state 123
    FALSE           shift and go to state 124
    NUMBER          shift and go to state 125
    NULL            shift and go to state 126
    NEW             shift and go to state 127
    ID              shift and go to state 114
    THIS            shift and go to state 129
    LPAREN          shift and go to state 130

  ! ID              [ reduce using rule 72 (empty -> .) ]

    exp                            shift and go to state 131
    rexp                           shift and go to state 116
    empty                          shift and go to state 117
    aexp                           shift and go to state 118
    mexp                           shift and go to state 119
    sexp                           shift and go to state 121
    pexp                           shift and go to state 128

state 102

    (29) cmd -> LCURLY cmds . RCURLY
    (28) cmds -> cmds . cmd
    (29) cmd -> . LCURLY cmds RCURLY
    (30) cmd -> . IF LPAREN exp RPAREN cmd
    (31) cmd -> . IF LPAREN exp RPAREN cmd ELSE cmd
    (32) cmd -> . WHILE LPAREN exp RPAREN cmd
    (33) cmd -> . PRINTLN LPAREN exp RPAREN SEMICOLON
    (34) cmd -> . ID ASSIGN exp SEMICOLON
    (35) cmd -> . ID LBRACKET exp RBRACKET ASSIGN exp SEMICOLON
    (36) cmd -> . empty
    (72) empty -> .

  ! shift/reduce conflict for RCURLY resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for LCURLY resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for PRINTLN resolved as shift
    RCURLY          shift and go to state 132
    LCURLY          shift and go to state 88
    IF              shift and go to state 91
    WHILE           shift and go to state 92
    PRINTLN         shift and go to state 93
    ID              shift and go to state 103
    PUBLIC          reduce using rule 72 (empty -> .)
    INT             reduce using rule 72 (empty -> .)
    BOOLEAN         reduce using rule 72 (empty -> .)
    RETURN          reduce using rule 72 (empty -> .)
    ELSE            reduce using rule 72 (empty -> .)
    SEMICOLON       reduce using rule 72 (empty -> .)
    RPAREN          reduce using rule 72 (empty -> .)
    RBRACKET        reduce using rule 72 (empty -> .)
    AND             reduce using rule 72 (empty -> .)
    COMMA           reduce using rule 72 (empty -> .)

  ! RCURLY          [ reduce using rule 72 (empty -> .) ]
  ! ID              [ reduce using rule 72 (empty -> .) ]
  ! LCURLY          [ reduce using rule 72 (empty -> .) ]
  ! IF              [ reduce using rule 72 (empty -> .) ]
  ! WHILE           [ reduce using rule 72 (empty -> .) ]
  ! PRINTLN         [ reduce using rule 72 (empty -> .) ]

    cmd                            shift and go to state 105
    empty                          shift and go to state 94

state 103

    (34) cmd -> ID . ASSIGN exp SEMICOLON
    (35) cmd -> ID . LBRACKET exp RBRACKET ASSIGN exp SEMICOLON

    ASSIGN          shift and go to state 100
    LBRACKET        shift and go to state 101


state 104

    (16) metodo -> PUBLIC tipo ID LPAREN RPAREN LCURLY vars cmds RETURN . exp SEMICOLON RCURLY
    (37) exp -> . exp AND rexp
    (38) exp -> . rexp
    (39) exp -> . empty
    (40) rexp -> . rexp LTHAN aexp
    (41) rexp -> . rexp EQUALS aexp
    (42) rexp -> . rexp DIFFERENT aexp
    (43) rexp -> . aexp
    (72) empty -> .
    (44) aexp -> . aexp PLUS mexp
    (45) aexp -> . aexp MINUS mexp
    (46) aexp -> . mexp
    (47) mexp -> . mexp TIMES sexp
    (48) mexp -> . sexp
    (49) sexp -> . NOT sexp
    (50) sexp -> . MINUS sexp
    (51) sexp -> . TRUE
    (52) sexp -> . FALSE
    (53) sexp -> . NUMBER
    (54) sexp -> . NULL
    (55) sexp -> . NEW INT LBRACKET exp RBRACKET
    (56) sexp -> . pexp DOT LENGTH
    (57) sexp -> . ID DOT LENGTH
    (58) sexp -> . pexp LBRACKET exp RBRACKET
    (59) sexp -> . ID LBRACKET exp RBRACKET
    (60) sexp -> . ID
    (61) pexp -> . THIS
    (62) pexp -> . NEW ID LPAREN RPAREN
    (63) pexp -> . LPAREN exp RPAREN
    (64) pexp -> . pexp DOT ID
    (65) pexp -> . ID DOT ID
    (66) pexp -> . pexp DOT ID LPAREN exps RPAREN
    (67) pexp -> . pexp DOT ID LPAREN RPAREN
    (68) pexp -> . ID DOT ID LPAREN exps RPAREN
    (69) pexp -> . ID DOT ID LPAREN RPAREN

  ! shift/reduce conflict for ID resolved as shift
    PUBLIC          reduce using rule 72 (empty -> .)
    RCURLY          reduce using rule 72 (empty -> .)
    INT             reduce using rule 72 (empty -> .)
    BOOLEAN         reduce using rule 72 (empty -> .)
    RETURN          reduce using rule 72 (empty -> .)
    LCURLY          reduce using rule 72 (empty -> .)
    IF              reduce using rule 72 (empty -> .)
    WHILE           reduce using rule 72 (empty -> .)
    PRINTLN         reduce using rule 72 (empty -> .)
    ELSE            reduce using rule 72 (empty -> .)
    SEMICOLON       reduce using rule 72 (empty -> .)
    RPAREN          reduce using rule 72 (empty -> .)
    RBRACKET        reduce using rule 72 (empty -> .)
    AND             reduce using rule 72 (empty -> .)
    COMMA           reduce using rule 72 (empty -> .)
    NOT             shift and go to state 122
    MINUS           shift and go to state 120
    TRUE            shift and go to state 123
    FALSE           shift and go to state 124
    NUMBER          shift and go to state 125
    NULL            shift and go to state 126
    NEW             shift and go to state 127
    ID              shift and go to state 114
    THIS            shift and go to state 129
    LPAREN          shift and go to state 130

  ! ID              [ reduce using rule 72 (empty -> .) ]

    exp                            shift and go to state 133
    rexp                           shift and go to state 116
    empty                          shift and go to state 117
    aexp                           shift and go to state 118
    mexp                           shift and go to state 119
    sexp                           shift and go to state 121
    pexp                           shift and go to state 128

state 105

    (28) cmds -> cmds cmd .

    RETURN          reduce using rule 28 (cmds -> cmds cmd .)
    LCURLY          reduce using rule 28 (cmds -> cmds cmd .)
    IF              reduce using rule 28 (cmds -> cmds cmd .)
    WHILE           reduce using rule 28 (cmds -> cmds cmd .)
    PRINTLN         reduce using rule 28 (cmds -> cmds cmd .)
    ID              reduce using rule 28 (cmds -> cmds cmd .)
    RCURLY          reduce using rule 28 (cmds -> cmds cmd .)


state 106

    (30) cmd -> IF LPAREN . exp RPAREN cmd
    (31) cmd -> IF LPAREN . exp RPAREN cmd ELSE cmd
    (37) exp -> . exp AND rexp
    (38) exp -> . rexp
    (39) exp -> . empty
    (40) rexp -> . rexp LTHAN aexp
    (41) rexp -> . rexp EQUALS aexp
    (42) rexp -> . rexp DIFFERENT aexp
    (43) rexp -> . aexp
    (72) empty -> .
    (44) aexp -> . aexp PLUS mexp
    (45) aexp -> . aexp MINUS mexp
    (46) aexp -> . mexp
    (47) mexp -> . mexp TIMES sexp
    (48) mexp -> . sexp
    (49) sexp -> . NOT sexp
    (50) sexp -> . MINUS sexp
    (51) sexp -> . TRUE
    (52) sexp -> . FALSE
    (53) sexp -> . NUMBER
    (54) sexp -> . NULL
    (55) sexp -> . NEW INT LBRACKET exp RBRACKET
    (56) sexp -> . pexp DOT LENGTH
    (57) sexp -> . ID DOT LENGTH
    (58) sexp -> . pexp LBRACKET exp RBRACKET
    (59) sexp -> . ID LBRACKET exp RBRACKET
    (60) sexp -> . ID
    (61) pexp -> . THIS
    (62) pexp -> . NEW ID LPAREN RPAREN
    (63) pexp -> . LPAREN exp RPAREN
    (64) pexp -> . pexp DOT ID
    (65) pexp -> . ID DOT ID
    (66) pexp -> . pexp DOT ID LPAREN exps RPAREN
    (67) pexp -> . pexp DOT ID LPAREN RPAREN
    (68) pexp -> . ID DOT ID LPAREN exps RPAREN
    (69) pexp -> . ID DOT ID LPAREN RPAREN

  ! shift/reduce conflict for ID resolved as shift
    PUBLIC          reduce using rule 72 (empty -> .)
    RCURLY          reduce using rule 72 (empty -> .)
    INT             reduce using rule 72 (empty -> .)
    BOOLEAN         reduce using rule 72 (empty -> .)
    RETURN          reduce using rule 72 (empty -> .)
    LCURLY          reduce using rule 72 (empty -> .)
    IF              reduce using rule 72 (empty -> .)
    WHILE           reduce using rule 72 (empty -> .)
    PRINTLN         reduce using rule 72 (empty -> .)
    ELSE            reduce using rule 72 (empty -> .)
    SEMICOLON       reduce using rule 72 (empty -> .)
    RPAREN          reduce using rule 72 (empty -> .)
    RBRACKET        reduce using rule 72 (empty -> .)
    AND             reduce using rule 72 (empty -> .)
    COMMA           reduce using rule 72 (empty -> .)
    NOT             shift and go to state 122
    MINUS           shift and go to state 120
    TRUE            shift and go to state 123
    FALSE           shift and go to state 124
    NUMBER          shift and go to state 125
    NULL            shift and go to state 126
    NEW             shift and go to state 127
    ID              shift and go to state 114
    THIS            shift and go to state 129
    LPAREN          shift and go to state 130

  ! ID              [ reduce using rule 72 (empty -> .) ]

    exp                            shift and go to state 134
    rexp                           shift and go to state 116
    empty                          shift and go to state 117
    aexp                           shift and go to state 118
    mexp                           shift and go to state 119
    sexp                           shift and go to state 121
    pexp                           shift and go to state 128

state 107

    (32) cmd -> WHILE LPAREN . exp RPAREN cmd
    (37) exp -> . exp AND rexp
    (38) exp -> . rexp
    (39) exp -> . empty
    (40) rexp -> . rexp LTHAN aexp
    (41) rexp -> . rexp EQUALS aexp
    (42) rexp -> . rexp DIFFERENT aexp
    (43) rexp -> . aexp
    (72) empty -> .
    (44) aexp -> . aexp PLUS mexp
    (45) aexp -> . aexp MINUS mexp
    (46) aexp -> . mexp
    (47) mexp -> . mexp TIMES sexp
    (48) mexp -> . sexp
    (49) sexp -> . NOT sexp
    (50) sexp -> . MINUS sexp
    (51) sexp -> . TRUE
    (52) sexp -> . FALSE
    (53) sexp -> . NUMBER
    (54) sexp -> . NULL
    (55) sexp -> . NEW INT LBRACKET exp RBRACKET
    (56) sexp -> . pexp DOT LENGTH
    (57) sexp -> . ID DOT LENGTH
    (58) sexp -> . pexp LBRACKET exp RBRACKET
    (59) sexp -> . ID LBRACKET exp RBRACKET
    (60) sexp -> . ID
    (61) pexp -> . THIS
    (62) pexp -> . NEW ID LPAREN RPAREN
    (63) pexp -> . LPAREN exp RPAREN
    (64) pexp -> . pexp DOT ID
    (65) pexp -> . ID DOT ID
    (66) pexp -> . pexp DOT ID LPAREN exps RPAREN
    (67) pexp -> . pexp DOT ID LPAREN RPAREN
    (68) pexp -> . ID DOT ID LPAREN exps RPAREN
    (69) pexp -> . ID DOT ID LPAREN RPAREN

  ! shift/reduce conflict for ID resolved as shift
    PUBLIC          reduce using rule 72 (empty -> .)
    RCURLY          reduce using rule 72 (empty -> .)
    INT             reduce using rule 72 (empty -> .)
    BOOLEAN         reduce using rule 72 (empty -> .)
    RETURN          reduce using rule 72 (empty -> .)
    LCURLY          reduce using rule 72 (empty -> .)
    IF              reduce using rule 72 (empty -> .)
    WHILE           reduce using rule 72 (empty -> .)
    PRINTLN         reduce using rule 72 (empty -> .)
    ELSE            reduce using rule 72 (empty -> .)
    SEMICOLON       reduce using rule 72 (empty -> .)
    RPAREN          reduce using rule 72 (empty -> .)
    RBRACKET        reduce using rule 72 (empty -> .)
    AND             reduce using rule 72 (empty -> .)
    COMMA           reduce using rule 72 (empty -> .)
    NOT             shift and go to state 122
    MINUS           shift and go to state 120
    TRUE            shift and go to state 123
    FALSE           shift and go to state 124
    NUMBER          shift and go to state 125
    NULL            shift and go to state 126
    NEW             shift and go to state 127
    ID              shift and go to state 114
    THIS            shift and go to state 129
    LPAREN          shift and go to state 130

  ! ID              [ reduce using rule 72 (empty -> .) ]

    exp                            shift and go to state 135
    rexp                           shift and go to state 116
    empty                          shift and go to state 117
    aexp                           shift and go to state 118
    mexp                           shift and go to state 119
    sexp                           shift and go to state 121
    pexp                           shift and go to state 128

state 108

    (33) cmd -> PRINTLN LPAREN . exp RPAREN SEMICOLON
    (37) exp -> . exp AND rexp
    (38) exp -> . rexp
    (39) exp -> . empty
    (40) rexp -> . rexp LTHAN aexp
    (41) rexp -> . rexp EQUALS aexp
    (42) rexp -> . rexp DIFFERENT aexp
    (43) rexp -> . aexp
    (72) empty -> .
    (44) aexp -> . aexp PLUS mexp
    (45) aexp -> . aexp MINUS mexp
    (46) aexp -> . mexp
    (47) mexp -> . mexp TIMES sexp
    (48) mexp -> . sexp
    (49) sexp -> . NOT sexp
    (50) sexp -> . MINUS sexp
    (51) sexp -> . TRUE
    (52) sexp -> . FALSE
    (53) sexp -> . NUMBER
    (54) sexp -> . NULL
    (55) sexp -> . NEW INT LBRACKET exp RBRACKET
    (56) sexp -> . pexp DOT LENGTH
    (57) sexp -> . ID DOT LENGTH
    (58) sexp -> . pexp LBRACKET exp RBRACKET
    (59) sexp -> . ID LBRACKET exp RBRACKET
    (60) sexp -> . ID
    (61) pexp -> . THIS
    (62) pexp -> . NEW ID LPAREN RPAREN
    (63) pexp -> . LPAREN exp RPAREN
    (64) pexp -> . pexp DOT ID
    (65) pexp -> . ID DOT ID
    (66) pexp -> . pexp DOT ID LPAREN exps RPAREN
    (67) pexp -> . pexp DOT ID LPAREN RPAREN
    (68) pexp -> . ID DOT ID LPAREN exps RPAREN
    (69) pexp -> . ID DOT ID LPAREN RPAREN

  ! shift/reduce conflict for ID resolved as shift
    PUBLIC          reduce using rule 72 (empty -> .)
    RCURLY          reduce using rule 72 (empty -> .)
    INT             reduce using rule 72 (empty -> .)
    BOOLEAN         reduce using rule 72 (empty -> .)
    RETURN          reduce using rule 72 (empty -> .)
    LCURLY          reduce using rule 72 (empty -> .)
    IF              reduce using rule 72 (empty -> .)
    WHILE           reduce using rule 72 (empty -> .)
    PRINTLN         reduce using rule 72 (empty -> .)
    ELSE            reduce using rule 72 (empty -> .)
    SEMICOLON       reduce using rule 72 (empty -> .)
    RPAREN          reduce using rule 72 (empty -> .)
    RBRACKET        reduce using rule 72 (empty -> .)
    AND             reduce using rule 72 (empty -> .)
    COMMA           reduce using rule 72 (empty -> .)
    NOT             shift and go to state 122
    MINUS           shift and go to state 120
    TRUE            shift and go to state 123
    FALSE           shift and go to state 124
    NUMBER          shift and go to state 125
    NULL            shift and go to state 126
    NEW             shift and go to state 127
    ID              shift and go to state 114
    THIS            shift and go to state 129
    LPAREN          shift and go to state 130

  ! ID              [ reduce using rule 72 (empty -> .) ]

    exp                            shift and go to state 136
    rexp                           shift and go to state 116
    empty                          shift and go to state 117
    aexp                           shift and go to state 118
    mexp                           shift and go to state 119
    sexp                           shift and go to state 121
    pexp                           shift and go to state 128

state 109

    (17) metodo -> PUBLIC ID ID LPAREN params RPAREN LCURLY vars cmds . RETURN exp SEMICOLON RCURLY
    (28) cmds -> cmds . cmd
    (29) cmd -> . LCURLY cmds RCURLY
    (30) cmd -> . IF LPAREN exp RPAREN cmd
    (31) cmd -> . IF LPAREN exp RPAREN cmd ELSE cmd
    (32) cmd -> . WHILE LPAREN exp RPAREN cmd
    (33) cmd -> . PRINTLN LPAREN exp RPAREN SEMICOLON
    (34) cmd -> . ID ASSIGN exp SEMICOLON
    (35) cmd -> . ID LBRACKET exp RBRACKET ASSIGN exp SEMICOLON
    (36) cmd -> . empty
    (72) empty -> .

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for LCURLY resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for PRINTLN resolved as shift
    RETURN          shift and go to state 137
    LCURLY          shift and go to state 88
    IF              shift and go to state 91
    WHILE           shift and go to state 92
    PRINTLN         shift and go to state 93
    ID              shift and go to state 103
    PUBLIC          reduce using rule 72 (empty -> .)
    RCURLY          reduce using rule 72 (empty -> .)
    INT             reduce using rule 72 (empty -> .)
    BOOLEAN         reduce using rule 72 (empty -> .)
    ELSE            reduce using rule 72 (empty -> .)
    SEMICOLON       reduce using rule 72 (empty -> .)
    RPAREN          reduce using rule 72 (empty -> .)
    RBRACKET        reduce using rule 72 (empty -> .)
    AND             reduce using rule 72 (empty -> .)
    COMMA           reduce using rule 72 (empty -> .)

  ! ID              [ reduce using rule 72 (empty -> .) ]
  ! RETURN          [ reduce using rule 72 (empty -> .) ]
  ! LCURLY          [ reduce using rule 72 (empty -> .) ]
  ! IF              [ reduce using rule 72 (empty -> .) ]
  ! WHILE           [ reduce using rule 72 (empty -> .) ]
  ! PRINTLN         [ reduce using rule 72 (empty -> .) ]

    cmd                            shift and go to state 105
    empty                          shift and go to state 94

state 110

    (18) metodo -> PUBLIC ID ID LPAREN RPAREN LCURLY vars cmds RETURN . exp SEMICOLON RCURLY
    (37) exp -> . exp AND rexp
    (38) exp -> . rexp
    (39) exp -> . empty
    (40) rexp -> . rexp LTHAN aexp
    (41) rexp -> . rexp EQUALS aexp
    (42) rexp -> . rexp DIFFERENT aexp
    (43) rexp -> . aexp
    (72) empty -> .
    (44) aexp -> . aexp PLUS mexp
    (45) aexp -> . aexp MINUS mexp
    (46) aexp -> . mexp
    (47) mexp -> . mexp TIMES sexp
    (48) mexp -> . sexp
    (49) sexp -> . NOT sexp
    (50) sexp -> . MINUS sexp
    (51) sexp -> . TRUE
    (52) sexp -> . FALSE
    (53) sexp -> . NUMBER
    (54) sexp -> . NULL
    (55) sexp -> . NEW INT LBRACKET exp RBRACKET
    (56) sexp -> . pexp DOT LENGTH
    (57) sexp -> . ID DOT LENGTH
    (58) sexp -> . pexp LBRACKET exp RBRACKET
    (59) sexp -> . ID LBRACKET exp RBRACKET
    (60) sexp -> . ID
    (61) pexp -> . THIS
    (62) pexp -> . NEW ID LPAREN RPAREN
    (63) pexp -> . LPAREN exp RPAREN
    (64) pexp -> . pexp DOT ID
    (65) pexp -> . ID DOT ID
    (66) pexp -> . pexp DOT ID LPAREN exps RPAREN
    (67) pexp -> . pexp DOT ID LPAREN RPAREN
    (68) pexp -> . ID DOT ID LPAREN exps RPAREN
    (69) pexp -> . ID DOT ID LPAREN RPAREN

  ! shift/reduce conflict for ID resolved as shift
    PUBLIC          reduce using rule 72 (empty -> .)
    RCURLY          reduce using rule 72 (empty -> .)
    INT             reduce using rule 72 (empty -> .)
    BOOLEAN         reduce using rule 72 (empty -> .)
    RETURN          reduce using rule 72 (empty -> .)
    LCURLY          reduce using rule 72 (empty -> .)
    IF              reduce using rule 72 (empty -> .)
    WHILE           reduce using rule 72 (empty -> .)
    PRINTLN         reduce using rule 72 (empty -> .)
    ELSE            reduce using rule 72 (empty -> .)
    SEMICOLON       reduce using rule 72 (empty -> .)
    RPAREN          reduce using rule 72 (empty -> .)
    RBRACKET        reduce using rule 72 (empty -> .)
    AND             reduce using rule 72 (empty -> .)
    COMMA           reduce using rule 72 (empty -> .)
    NOT             shift and go to state 122
    MINUS           shift and go to state 120
    TRUE            shift and go to state 123
    FALSE           shift and go to state 124
    NUMBER          shift and go to state 125
    NULL            shift and go to state 126
    NEW             shift and go to state 127
    ID              shift and go to state 114
    THIS            shift and go to state 129
    LPAREN          shift and go to state 130

  ! ID              [ reduce using rule 72 (empty -> .) ]

    exp                            shift and go to state 138
    rexp                           shift and go to state 116
    empty                          shift and go to state 117
    aexp                           shift and go to state 118
    mexp                           shift and go to state 119
    sexp                           shift and go to state 121
    pexp                           shift and go to state 128

state 111

    (2) main -> CLASS ID LCURLY PUBLIC STATIC VOID MAIN LPAREN STRING LBRACKET RBRACKET ID RPAREN LCURLY . cmd RCURLY RCURLY
    (29) cmd -> . LCURLY cmds RCURLY
    (30) cmd -> . IF LPAREN exp RPAREN cmd
    (31) cmd -> . IF LPAREN exp RPAREN cmd ELSE cmd
    (32) cmd -> . WHILE LPAREN exp RPAREN cmd
    (33) cmd -> . PRINTLN LPAREN exp RPAREN SEMICOLON
    (34) cmd -> . ID ASSIGN exp SEMICOLON
    (35) cmd -> . ID LBRACKET exp RBRACKET ASSIGN exp SEMICOLON
    (36) cmd -> . empty
    (72) empty -> .

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for LCURLY resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for PRINTLN resolved as shift
    LCURLY          shift and go to state 88
    IF              shift and go to state 91
    WHILE           shift and go to state 92
    PRINTLN         shift and go to state 93
    ID              shift and go to state 103
    PUBLIC          reduce using rule 72 (empty -> .)
    RCURLY          reduce using rule 72 (empty -> .)
    INT             reduce using rule 72 (empty -> .)
    BOOLEAN         reduce using rule 72 (empty -> .)
    RETURN          reduce using rule 72 (empty -> .)
    ELSE            reduce using rule 72 (empty -> .)
    SEMICOLON       reduce using rule 72 (empty -> .)
    RPAREN          reduce using rule 72 (empty -> .)
    RBRACKET        reduce using rule 72 (empty -> .)
    AND             reduce using rule 72 (empty -> .)
    COMMA           reduce using rule 72 (empty -> .)

  ! ID              [ reduce using rule 72 (empty -> .) ]
  ! LCURLY          [ reduce using rule 72 (empty -> .) ]
  ! IF              [ reduce using rule 72 (empty -> .) ]
  ! WHILE           [ reduce using rule 72 (empty -> .) ]
  ! PRINTLN         [ reduce using rule 72 (empty -> .) ]

    cmd                            shift and go to state 139
    empty                          shift and go to state 94

state 112

    (3) main -> ID LCURLY PUBLIC STATIC VOID MAIN LPAREN STRING LBRACKET RBRACKET ID RPAREN LCURLY cmd . RCURLY RCURLY

    RCURLY          shift and go to state 140


state 113

    (15) metodo -> PUBLIC tipo ID LPAREN params RPAREN LCURLY vars cmds RETURN . exp SEMICOLON RCURLY
    (37) exp -> . exp AND rexp
    (38) exp -> . rexp
    (39) exp -> . empty
    (40) rexp -> . rexp LTHAN aexp
    (41) rexp -> . rexp EQUALS aexp
    (42) rexp -> . rexp DIFFERENT aexp
    (43) rexp -> . aexp
    (72) empty -> .
    (44) aexp -> . aexp PLUS mexp
    (45) aexp -> . aexp MINUS mexp
    (46) aexp -> . mexp
    (47) mexp -> . mexp TIMES sexp
    (48) mexp -> . sexp
    (49) sexp -> . NOT sexp
    (50) sexp -> . MINUS sexp
    (51) sexp -> . TRUE
    (52) sexp -> . FALSE
    (53) sexp -> . NUMBER
    (54) sexp -> . NULL
    (55) sexp -> . NEW INT LBRACKET exp RBRACKET
    (56) sexp -> . pexp DOT LENGTH
    (57) sexp -> . ID DOT LENGTH
    (58) sexp -> . pexp LBRACKET exp RBRACKET
    (59) sexp -> . ID LBRACKET exp RBRACKET
    (60) sexp -> . ID
    (61) pexp -> . THIS
    (62) pexp -> . NEW ID LPAREN RPAREN
    (63) pexp -> . LPAREN exp RPAREN
    (64) pexp -> . pexp DOT ID
    (65) pexp -> . ID DOT ID
    (66) pexp -> . pexp DOT ID LPAREN exps RPAREN
    (67) pexp -> . pexp DOT ID LPAREN RPAREN
    (68) pexp -> . ID DOT ID LPAREN exps RPAREN
    (69) pexp -> . ID DOT ID LPAREN RPAREN

  ! shift/reduce conflict for ID resolved as shift
    PUBLIC          reduce using rule 72 (empty -> .)
    RCURLY          reduce using rule 72 (empty -> .)
    INT             reduce using rule 72 (empty -> .)
    BOOLEAN         reduce using rule 72 (empty -> .)
    RETURN          reduce using rule 72 (empty -> .)
    LCURLY          reduce using rule 72 (empty -> .)
    IF              reduce using rule 72 (empty -> .)
    WHILE           reduce using rule 72 (empty -> .)
    PRINTLN         reduce using rule 72 (empty -> .)
    ELSE            reduce using rule 72 (empty -> .)
    SEMICOLON       reduce using rule 72 (empty -> .)
    RPAREN          reduce using rule 72 (empty -> .)
    RBRACKET        reduce using rule 72 (empty -> .)
    AND             reduce using rule 72 (empty -> .)
    COMMA           reduce using rule 72 (empty -> .)
    NOT             shift and go to state 122
    MINUS           shift and go to state 120
    TRUE            shift and go to state 123
    FALSE           shift and go to state 124
    NUMBER          shift and go to state 125
    NULL            shift and go to state 126
    NEW             shift and go to state 127
    ID              shift and go to state 114
    THIS            shift and go to state 129
    LPAREN          shift and go to state 130

  ! ID              [ reduce using rule 72 (empty -> .) ]

    exp                            shift and go to state 141
    rexp                           shift and go to state 116
    empty                          shift and go to state 117
    aexp                           shift and go to state 118
    mexp                           shift and go to state 119
    sexp                           shift and go to state 121
    pexp                           shift and go to state 128

state 114

    (57) sexp -> ID . DOT LENGTH
    (59) sexp -> ID . LBRACKET exp RBRACKET
    (60) sexp -> ID .
    (65) pexp -> ID . DOT ID
    (68) pexp -> ID . DOT ID LPAREN exps RPAREN
    (69) pexp -> ID . DOT ID LPAREN RPAREN

    DOT             shift and go to state 142
    LBRACKET        shift and go to state 143
    SEMICOLON       reduce using rule 60 (sexp -> ID .)
    RPAREN          reduce using rule 60 (sexp -> ID .)
    RBRACKET        reduce using rule 60 (sexp -> ID .)
    AND             reduce using rule 60 (sexp -> ID .)
    LTHAN           reduce using rule 60 (sexp -> ID .)
    EQUALS          reduce using rule 60 (sexp -> ID .)
    DIFFERENT       reduce using rule 60 (sexp -> ID .)
    PLUS            reduce using rule 60 (sexp -> ID .)
    MINUS           reduce using rule 60 (sexp -> ID .)
    TIMES           reduce using rule 60 (sexp -> ID .)
    COMMA           reduce using rule 60 (sexp -> ID .)


state 115

    (34) cmd -> ID ASSIGN exp . SEMICOLON
    (37) exp -> exp . AND rexp

    SEMICOLON       shift and go to state 144
    AND             shift and go to state 145


state 116

    (38) exp -> rexp .
    (40) rexp -> rexp . LTHAN aexp
    (41) rexp -> rexp . EQUALS aexp
    (42) rexp -> rexp . DIFFERENT aexp

    SEMICOLON       reduce using rule 38 (exp -> rexp .)
    RPAREN          reduce using rule 38 (exp -> rexp .)
    RBRACKET        reduce using rule 38 (exp -> rexp .)
    AND             reduce using rule 38 (exp -> rexp .)
    COMMA           reduce using rule 38 (exp -> rexp .)
    LTHAN           shift and go to state 146
    EQUALS          shift and go to state 147
    DIFFERENT       shift and go to state 148


state 117

    (39) exp -> empty .

    SEMICOLON       reduce using rule 39 (exp -> empty .)
    RPAREN          reduce using rule 39 (exp -> empty .)
    RBRACKET        reduce using rule 39 (exp -> empty .)
    AND             reduce using rule 39 (exp -> empty .)
    COMMA           reduce using rule 39 (exp -> empty .)


state 118

    (43) rexp -> aexp .
    (44) aexp -> aexp . PLUS mexp
    (45) aexp -> aexp . MINUS mexp

    SEMICOLON       reduce using rule 43 (rexp -> aexp .)
    RPAREN          reduce using rule 43 (rexp -> aexp .)
    RBRACKET        reduce using rule 43 (rexp -> aexp .)
    AND             reduce using rule 43 (rexp -> aexp .)
    LTHAN           reduce using rule 43 (rexp -> aexp .)
    EQUALS          reduce using rule 43 (rexp -> aexp .)
    DIFFERENT       reduce using rule 43 (rexp -> aexp .)
    COMMA           reduce using rule 43 (rexp -> aexp .)
    PLUS            shift and go to state 149
    MINUS           shift and go to state 150


state 119

    (46) aexp -> mexp .
    (47) mexp -> mexp . TIMES sexp

    SEMICOLON       reduce using rule 46 (aexp -> mexp .)
    RPAREN          reduce using rule 46 (aexp -> mexp .)
    RBRACKET        reduce using rule 46 (aexp -> mexp .)
    AND             reduce using rule 46 (aexp -> mexp .)
    LTHAN           reduce using rule 46 (aexp -> mexp .)
    EQUALS          reduce using rule 46 (aexp -> mexp .)
    DIFFERENT       reduce using rule 46 (aexp -> mexp .)
    PLUS            reduce using rule 46 (aexp -> mexp .)
    MINUS           reduce using rule 46 (aexp -> mexp .)
    COMMA           reduce using rule 46 (aexp -> mexp .)
    TIMES           shift and go to state 151


state 120

    (50) sexp -> MINUS . sexp
    (49) sexp -> . NOT sexp
    (50) sexp -> . MINUS sexp
    (51) sexp -> . TRUE
    (52) sexp -> . FALSE
    (53) sexp -> . NUMBER
    (54) sexp -> . NULL
    (55) sexp -> . NEW INT LBRACKET exp RBRACKET
    (56) sexp -> . pexp DOT LENGTH
    (57) sexp -> . ID DOT LENGTH
    (58) sexp -> . pexp LBRACKET exp RBRACKET
    (59) sexp -> . ID LBRACKET exp RBRACKET
    (60) sexp -> . ID
    (61) pexp -> . THIS
    (62) pexp -> . NEW ID LPAREN RPAREN
    (63) pexp -> . LPAREN exp RPAREN
    (64) pexp -> . pexp DOT ID
    (65) pexp -> . ID DOT ID
    (66) pexp -> . pexp DOT ID LPAREN exps RPAREN
    (67) pexp -> . pexp DOT ID LPAREN RPAREN
    (68) pexp -> . ID DOT ID LPAREN exps RPAREN
    (69) pexp -> . ID DOT ID LPAREN RPAREN

    NOT             shift and go to state 122
    MINUS           shift and go to state 120
    TRUE            shift and go to state 123
    FALSE           shift and go to state 124
    NUMBER          shift and go to state 125
    NULL            shift and go to state 126
    NEW             shift and go to state 127
    ID              shift and go to state 114
    THIS            shift and go to state 129
    LPAREN          shift and go to state 130

    sexp                           shift and go to state 152
    pexp                           shift and go to state 128

state 121

    (48) mexp -> sexp .

    SEMICOLON       reduce using rule 48 (mexp -> sexp .)
    RPAREN          reduce using rule 48 (mexp -> sexp .)
    RBRACKET        reduce using rule 48 (mexp -> sexp .)
    AND             reduce using rule 48 (mexp -> sexp .)
    LTHAN           reduce using rule 48 (mexp -> sexp .)
    EQUALS          reduce using rule 48 (mexp -> sexp .)
    DIFFERENT       reduce using rule 48 (mexp -> sexp .)
    PLUS            reduce using rule 48 (mexp -> sexp .)
    MINUS           reduce using rule 48 (mexp -> sexp .)
    TIMES           reduce using rule 48 (mexp -> sexp .)
    COMMA           reduce using rule 48 (mexp -> sexp .)


state 122

    (49) sexp -> NOT . sexp
    (49) sexp -> . NOT sexp
    (50) sexp -> . MINUS sexp
    (51) sexp -> . TRUE
    (52) sexp -> . FALSE
    (53) sexp -> . NUMBER
    (54) sexp -> . NULL
    (55) sexp -> . NEW INT LBRACKET exp RBRACKET
    (56) sexp -> . pexp DOT LENGTH
    (57) sexp -> . ID DOT LENGTH
    (58) sexp -> . pexp LBRACKET exp RBRACKET
    (59) sexp -> . ID LBRACKET exp RBRACKET
    (60) sexp -> . ID
    (61) pexp -> . THIS
    (62) pexp -> . NEW ID LPAREN RPAREN
    (63) pexp -> . LPAREN exp RPAREN
    (64) pexp -> . pexp DOT ID
    (65) pexp -> . ID DOT ID
    (66) pexp -> . pexp DOT ID LPAREN exps RPAREN
    (67) pexp -> . pexp DOT ID LPAREN RPAREN
    (68) pexp -> . ID DOT ID LPAREN exps RPAREN
    (69) pexp -> . ID DOT ID LPAREN RPAREN

    NOT             shift and go to state 122
    MINUS           shift and go to state 120
    TRUE            shift and go to state 123
    FALSE           shift and go to state 124
    NUMBER          shift and go to state 125
    NULL            shift and go to state 126
    NEW             shift and go to state 127
    ID              shift and go to state 114
    THIS            shift and go to state 129
    LPAREN          shift and go to state 130

    sexp                           shift and go to state 153
    pexp                           shift and go to state 128

state 123

    (51) sexp -> TRUE .

    SEMICOLON       reduce using rule 51 (sexp -> TRUE .)
    RPAREN          reduce using rule 51 (sexp -> TRUE .)
    RBRACKET        reduce using rule 51 (sexp -> TRUE .)
    AND             reduce using rule 51 (sexp -> TRUE .)
    LTHAN           reduce using rule 51 (sexp -> TRUE .)
    EQUALS          reduce using rule 51 (sexp -> TRUE .)
    DIFFERENT       reduce using rule 51 (sexp -> TRUE .)
    PLUS            reduce using rule 51 (sexp -> TRUE .)
    MINUS           reduce using rule 51 (sexp -> TRUE .)
    TIMES           reduce using rule 51 (sexp -> TRUE .)
    COMMA           reduce using rule 51 (sexp -> TRUE .)


state 124

    (52) sexp -> FALSE .

    SEMICOLON       reduce using rule 52 (sexp -> FALSE .)
    RPAREN          reduce using rule 52 (sexp -> FALSE .)
    RBRACKET        reduce using rule 52 (sexp -> FALSE .)
    AND             reduce using rule 52 (sexp -> FALSE .)
    LTHAN           reduce using rule 52 (sexp -> FALSE .)
    EQUALS          reduce using rule 52 (sexp -> FALSE .)
    DIFFERENT       reduce using rule 52 (sexp -> FALSE .)
    PLUS            reduce using rule 52 (sexp -> FALSE .)
    MINUS           reduce using rule 52 (sexp -> FALSE .)
    TIMES           reduce using rule 52 (sexp -> FALSE .)
    COMMA           reduce using rule 52 (sexp -> FALSE .)


state 125

    (53) sexp -> NUMBER .

    SEMICOLON       reduce using rule 53 (sexp -> NUMBER .)
    RPAREN          reduce using rule 53 (sexp -> NUMBER .)
    RBRACKET        reduce using rule 53 (sexp -> NUMBER .)
    AND             reduce using rule 53 (sexp -> NUMBER .)
    LTHAN           reduce using rule 53 (sexp -> NUMBER .)
    EQUALS          reduce using rule 53 (sexp -> NUMBER .)
    DIFFERENT       reduce using rule 53 (sexp -> NUMBER .)
    PLUS            reduce using rule 53 (sexp -> NUMBER .)
    MINUS           reduce using rule 53 (sexp -> NUMBER .)
    TIMES           reduce using rule 53 (sexp -> NUMBER .)
    COMMA           reduce using rule 53 (sexp -> NUMBER .)


state 126

    (54) sexp -> NULL .

    SEMICOLON       reduce using rule 54 (sexp -> NULL .)
    RPAREN          reduce using rule 54 (sexp -> NULL .)
    RBRACKET        reduce using rule 54 (sexp -> NULL .)
    AND             reduce using rule 54 (sexp -> NULL .)
    LTHAN           reduce using rule 54 (sexp -> NULL .)
    EQUALS          reduce using rule 54 (sexp -> NULL .)
    DIFFERENT       reduce using rule 54 (sexp -> NULL .)
    PLUS            reduce using rule 54 (sexp -> NULL .)
    MINUS           reduce using rule 54 (sexp -> NULL .)
    TIMES           reduce using rule 54 (sexp -> NULL .)
    COMMA           reduce using rule 54 (sexp -> NULL .)


state 127

    (55) sexp -> NEW . INT LBRACKET exp RBRACKET
    (62) pexp -> NEW . ID LPAREN RPAREN

    INT             shift and go to state 154
    ID              shift and go to state 155


state 128

    (56) sexp -> pexp . DOT LENGTH
    (58) sexp -> pexp . LBRACKET exp RBRACKET
    (64) pexp -> pexp . DOT ID
    (66) pexp -> pexp . DOT ID LPAREN exps RPAREN
    (67) pexp -> pexp . DOT ID LPAREN RPAREN

    DOT             shift and go to state 156
    LBRACKET        shift and go to state 157


state 129

    (61) pexp -> THIS .

    DOT             reduce using rule 61 (pexp -> THIS .)
    LBRACKET        reduce using rule 61 (pexp -> THIS .)


state 130

    (63) pexp -> LPAREN . exp RPAREN
    (37) exp -> . exp AND rexp
    (38) exp -> . rexp
    (39) exp -> . empty
    (40) rexp -> . rexp LTHAN aexp
    (41) rexp -> . rexp EQUALS aexp
    (42) rexp -> . rexp DIFFERENT aexp
    (43) rexp -> . aexp
    (72) empty -> .
    (44) aexp -> . aexp PLUS mexp
    (45) aexp -> . aexp MINUS mexp
    (46) aexp -> . mexp
    (47) mexp -> . mexp TIMES sexp
    (48) mexp -> . sexp
    (49) sexp -> . NOT sexp
    (50) sexp -> . MINUS sexp
    (51) sexp -> . TRUE
    (52) sexp -> . FALSE
    (53) sexp -> . NUMBER
    (54) sexp -> . NULL
    (55) sexp -> . NEW INT LBRACKET exp RBRACKET
    (56) sexp -> . pexp DOT LENGTH
    (57) sexp -> . ID DOT LENGTH
    (58) sexp -> . pexp LBRACKET exp RBRACKET
    (59) sexp -> . ID LBRACKET exp RBRACKET
    (60) sexp -> . ID
    (61) pexp -> . THIS
    (62) pexp -> . NEW ID LPAREN RPAREN
    (63) pexp -> . LPAREN exp RPAREN
    (64) pexp -> . pexp DOT ID
    (65) pexp -> . ID DOT ID
    (66) pexp -> . pexp DOT ID LPAREN exps RPAREN
    (67) pexp -> . pexp DOT ID LPAREN RPAREN
    (68) pexp -> . ID DOT ID LPAREN exps RPAREN
    (69) pexp -> . ID DOT ID LPAREN RPAREN

  ! shift/reduce conflict for ID resolved as shift
    PUBLIC          reduce using rule 72 (empty -> .)
    RCURLY          reduce using rule 72 (empty -> .)
    INT             reduce using rule 72 (empty -> .)
    BOOLEAN         reduce using rule 72 (empty -> .)
    RETURN          reduce using rule 72 (empty -> .)
    LCURLY          reduce using rule 72 (empty -> .)
    IF              reduce using rule 72 (empty -> .)
    WHILE           reduce using rule 72 (empty -> .)
    PRINTLN         reduce using rule 72 (empty -> .)
    ELSE            reduce using rule 72 (empty -> .)
    SEMICOLON       reduce using rule 72 (empty -> .)
    RPAREN          reduce using rule 72 (empty -> .)
    RBRACKET        reduce using rule 72 (empty -> .)
    AND             reduce using rule 72 (empty -> .)
    COMMA           reduce using rule 72 (empty -> .)
    NOT             shift and go to state 122
    MINUS           shift and go to state 120
    TRUE            shift and go to state 123
    FALSE           shift and go to state 124
    NUMBER          shift and go to state 125
    NULL            shift and go to state 126
    NEW             shift and go to state 127
    ID              shift and go to state 114
    THIS            shift and go to state 129
    LPAREN          shift and go to state 130

  ! ID              [ reduce using rule 72 (empty -> .) ]

    exp                            shift and go to state 158
    rexp                           shift and go to state 116
    empty                          shift and go to state 117
    aexp                           shift and go to state 118
    mexp                           shift and go to state 119
    sexp                           shift and go to state 121
    pexp                           shift and go to state 128

state 131

    (35) cmd -> ID LBRACKET exp . RBRACKET ASSIGN exp SEMICOLON
    (37) exp -> exp . AND rexp

    RBRACKET        shift and go to state 159
    AND             shift and go to state 145


state 132

    (29) cmd -> LCURLY cmds RCURLY .

    RCURLY          reduce using rule 29 (cmd -> LCURLY cmds RCURLY .)
    RETURN          reduce using rule 29 (cmd -> LCURLY cmds RCURLY .)
    LCURLY          reduce using rule 29 (cmd -> LCURLY cmds RCURLY .)
    IF              reduce using rule 29 (cmd -> LCURLY cmds RCURLY .)
    WHILE           reduce using rule 29 (cmd -> LCURLY cmds RCURLY .)
    PRINTLN         reduce using rule 29 (cmd -> LCURLY cmds RCURLY .)
    ID              reduce using rule 29 (cmd -> LCURLY cmds RCURLY .)
    ELSE            reduce using rule 29 (cmd -> LCURLY cmds RCURLY .)


state 133

    (16) metodo -> PUBLIC tipo ID LPAREN RPAREN LCURLY vars cmds RETURN exp . SEMICOLON RCURLY
    (37) exp -> exp . AND rexp

    SEMICOLON       shift and go to state 160
    AND             shift and go to state 145


state 134

    (30) cmd -> IF LPAREN exp . RPAREN cmd
    (31) cmd -> IF LPAREN exp . RPAREN cmd ELSE cmd
    (37) exp -> exp . AND rexp

    RPAREN          shift and go to state 161
    AND             shift and go to state 145


state 135

    (32) cmd -> WHILE LPAREN exp . RPAREN cmd
    (37) exp -> exp . AND rexp

    RPAREN          shift and go to state 162
    AND             shift and go to state 145


state 136

    (33) cmd -> PRINTLN LPAREN exp . RPAREN SEMICOLON
    (37) exp -> exp . AND rexp

    RPAREN          shift and go to state 163
    AND             shift and go to state 145


state 137

    (17) metodo -> PUBLIC ID ID LPAREN params RPAREN LCURLY vars cmds RETURN . exp SEMICOLON RCURLY
    (37) exp -> . exp AND rexp
    (38) exp -> . rexp
    (39) exp -> . empty
    (40) rexp -> . rexp LTHAN aexp
    (41) rexp -> . rexp EQUALS aexp
    (42) rexp -> . rexp DIFFERENT aexp
    (43) rexp -> . aexp
    (72) empty -> .
    (44) aexp -> . aexp PLUS mexp
    (45) aexp -> . aexp MINUS mexp
    (46) aexp -> . mexp
    (47) mexp -> . mexp TIMES sexp
    (48) mexp -> . sexp
    (49) sexp -> . NOT sexp
    (50) sexp -> . MINUS sexp
    (51) sexp -> . TRUE
    (52) sexp -> . FALSE
    (53) sexp -> . NUMBER
    (54) sexp -> . NULL
    (55) sexp -> . NEW INT LBRACKET exp RBRACKET
    (56) sexp -> . pexp DOT LENGTH
    (57) sexp -> . ID DOT LENGTH
    (58) sexp -> . pexp LBRACKET exp RBRACKET
    (59) sexp -> . ID LBRACKET exp RBRACKET
    (60) sexp -> . ID
    (61) pexp -> . THIS
    (62) pexp -> . NEW ID LPAREN RPAREN
    (63) pexp -> . LPAREN exp RPAREN
    (64) pexp -> . pexp DOT ID
    (65) pexp -> . ID DOT ID
    (66) pexp -> . pexp DOT ID LPAREN exps RPAREN
    (67) pexp -> . pexp DOT ID LPAREN RPAREN
    (68) pexp -> . ID DOT ID LPAREN exps RPAREN
    (69) pexp -> . ID DOT ID LPAREN RPAREN

  ! shift/reduce conflict for ID resolved as shift
    PUBLIC          reduce using rule 72 (empty -> .)
    RCURLY          reduce using rule 72 (empty -> .)
    INT             reduce using rule 72 (empty -> .)
    BOOLEAN         reduce using rule 72 (empty -> .)
    RETURN          reduce using rule 72 (empty -> .)
    LCURLY          reduce using rule 72 (empty -> .)
    IF              reduce using rule 72 (empty -> .)
    WHILE           reduce using rule 72 (empty -> .)
    PRINTLN         reduce using rule 72 (empty -> .)
    ELSE            reduce using rule 72 (empty -> .)
    SEMICOLON       reduce using rule 72 (empty -> .)
    RPAREN          reduce using rule 72 (empty -> .)
    RBRACKET        reduce using rule 72 (empty -> .)
    AND             reduce using rule 72 (empty -> .)
    COMMA           reduce using rule 72 (empty -> .)
    NOT             shift and go to state 122
    MINUS           shift and go to state 120
    TRUE            shift and go to state 123
    FALSE           shift and go to state 124
    NUMBER          shift and go to state 125
    NULL            shift and go to state 126
    NEW             shift and go to state 127
    ID              shift and go to state 114
    THIS            shift and go to state 129
    LPAREN          shift and go to state 130

  ! ID              [ reduce using rule 72 (empty -> .) ]

    exp                            shift and go to state 164
    rexp                           shift and go to state 116
    empty                          shift and go to state 117
    aexp                           shift and go to state 118
    mexp                           shift and go to state 119
    sexp                           shift and go to state 121
    pexp                           shift and go to state 128

state 138

    (18) metodo -> PUBLIC ID ID LPAREN RPAREN LCURLY vars cmds RETURN exp . SEMICOLON RCURLY
    (37) exp -> exp . AND rexp

    SEMICOLON       shift and go to state 165
    AND             shift and go to state 145


state 139

    (2) main -> CLASS ID LCURLY PUBLIC STATIC VOID MAIN LPAREN STRING LBRACKET RBRACKET ID RPAREN LCURLY cmd . RCURLY RCURLY

    RCURLY          shift and go to state 166


state 140

    (3) main -> ID LCURLY PUBLIC STATIC VOID MAIN LPAREN STRING LBRACKET RBRACKET ID RPAREN LCURLY cmd RCURLY . RCURLY

    RCURLY          shift and go to state 167


state 141

    (15) metodo -> PUBLIC tipo ID LPAREN params RPAREN LCURLY vars cmds RETURN exp . SEMICOLON RCURLY
    (37) exp -> exp . AND rexp

    SEMICOLON       shift and go to state 168
    AND             shift and go to state 145


state 142

    (57) sexp -> ID DOT . LENGTH
    (65) pexp -> ID DOT . ID
    (68) pexp -> ID DOT . ID LPAREN exps RPAREN
    (69) pexp -> ID DOT . ID LPAREN RPAREN

    LENGTH          shift and go to state 170
    ID              shift and go to state 169


state 143

    (59) sexp -> ID LBRACKET . exp RBRACKET
    (37) exp -> . exp AND rexp
    (38) exp -> . rexp
    (39) exp -> . empty
    (40) rexp -> . rexp LTHAN aexp
    (41) rexp -> . rexp EQUALS aexp
    (42) rexp -> . rexp DIFFERENT aexp
    (43) rexp -> . aexp
    (72) empty -> .
    (44) aexp -> . aexp PLUS mexp
    (45) aexp -> . aexp MINUS mexp
    (46) aexp -> . mexp
    (47) mexp -> . mexp TIMES sexp
    (48) mexp -> . sexp
    (49) sexp -> . NOT sexp
    (50) sexp -> . MINUS sexp
    (51) sexp -> . TRUE
    (52) sexp -> . FALSE
    (53) sexp -> . NUMBER
    (54) sexp -> . NULL
    (55) sexp -> . NEW INT LBRACKET exp RBRACKET
    (56) sexp -> . pexp DOT LENGTH
    (57) sexp -> . ID DOT LENGTH
    (58) sexp -> . pexp LBRACKET exp RBRACKET
    (59) sexp -> . ID LBRACKET exp RBRACKET
    (60) sexp -> . ID
    (61) pexp -> . THIS
    (62) pexp -> . NEW ID LPAREN RPAREN
    (63) pexp -> . LPAREN exp RPAREN
    (64) pexp -> . pexp DOT ID
    (65) pexp -> . ID DOT ID
    (66) pexp -> . pexp DOT ID LPAREN exps RPAREN
    (67) pexp -> . pexp DOT ID LPAREN RPAREN
    (68) pexp -> . ID DOT ID LPAREN exps RPAREN
    (69) pexp -> . ID DOT ID LPAREN RPAREN

  ! shift/reduce conflict for ID resolved as shift
    PUBLIC          reduce using rule 72 (empty -> .)
    RCURLY          reduce using rule 72 (empty -> .)
    INT             reduce using rule 72 (empty -> .)
    BOOLEAN         reduce using rule 72 (empty -> .)
    RETURN          reduce using rule 72 (empty -> .)
    LCURLY          reduce using rule 72 (empty -> .)
    IF              reduce using rule 72 (empty -> .)
    WHILE           reduce using rule 72 (empty -> .)
    PRINTLN         reduce using rule 72 (empty -> .)
    ELSE            reduce using rule 72 (empty -> .)
    SEMICOLON       reduce using rule 72 (empty -> .)
    RPAREN          reduce using rule 72 (empty -> .)
    RBRACKET        reduce using rule 72 (empty -> .)
    AND             reduce using rule 72 (empty -> .)
    COMMA           reduce using rule 72 (empty -> .)
    NOT             shift and go to state 122
    MINUS           shift and go to state 120
    TRUE            shift and go to state 123
    FALSE           shift and go to state 124
    NUMBER          shift and go to state 125
    NULL            shift and go to state 126
    NEW             shift and go to state 127
    ID              shift and go to state 114
    THIS            shift and go to state 129
    LPAREN          shift and go to state 130

  ! ID              [ reduce using rule 72 (empty -> .) ]

    exp                            shift and go to state 171
    rexp                           shift and go to state 116
    empty                          shift and go to state 117
    aexp                           shift and go to state 118
    mexp                           shift and go to state 119
    sexp                           shift and go to state 121
    pexp                           shift and go to state 128

state 144

    (34) cmd -> ID ASSIGN exp SEMICOLON .

    RCURLY          reduce using rule 34 (cmd -> ID ASSIGN exp SEMICOLON .)
    RETURN          reduce using rule 34 (cmd -> ID ASSIGN exp SEMICOLON .)
    LCURLY          reduce using rule 34 (cmd -> ID ASSIGN exp SEMICOLON .)
    IF              reduce using rule 34 (cmd -> ID ASSIGN exp SEMICOLON .)
    WHILE           reduce using rule 34 (cmd -> ID ASSIGN exp SEMICOLON .)
    PRINTLN         reduce using rule 34 (cmd -> ID ASSIGN exp SEMICOLON .)
    ID              reduce using rule 34 (cmd -> ID ASSIGN exp SEMICOLON .)
    ELSE            reduce using rule 34 (cmd -> ID ASSIGN exp SEMICOLON .)


state 145

    (37) exp -> exp AND . rexp
    (40) rexp -> . rexp LTHAN aexp
    (41) rexp -> . rexp EQUALS aexp
    (42) rexp -> . rexp DIFFERENT aexp
    (43) rexp -> . aexp
    (44) aexp -> . aexp PLUS mexp
    (45) aexp -> . aexp MINUS mexp
    (46) aexp -> . mexp
    (47) mexp -> . mexp TIMES sexp
    (48) mexp -> . sexp
    (49) sexp -> . NOT sexp
    (50) sexp -> . MINUS sexp
    (51) sexp -> . TRUE
    (52) sexp -> . FALSE
    (53) sexp -> . NUMBER
    (54) sexp -> . NULL
    (55) sexp -> . NEW INT LBRACKET exp RBRACKET
    (56) sexp -> . pexp DOT LENGTH
    (57) sexp -> . ID DOT LENGTH
    (58) sexp -> . pexp LBRACKET exp RBRACKET
    (59) sexp -> . ID LBRACKET exp RBRACKET
    (60) sexp -> . ID
    (61) pexp -> . THIS
    (62) pexp -> . NEW ID LPAREN RPAREN
    (63) pexp -> . LPAREN exp RPAREN
    (64) pexp -> . pexp DOT ID
    (65) pexp -> . ID DOT ID
    (66) pexp -> . pexp DOT ID LPAREN exps RPAREN
    (67) pexp -> . pexp DOT ID LPAREN RPAREN
    (68) pexp -> . ID DOT ID LPAREN exps RPAREN
    (69) pexp -> . ID DOT ID LPAREN RPAREN

    NOT             shift and go to state 122
    MINUS           shift and go to state 120
    TRUE            shift and go to state 123
    FALSE           shift and go to state 124
    NUMBER          shift and go to state 125
    NULL            shift and go to state 126
    NEW             shift and go to state 127
    ID              shift and go to state 114
    THIS            shift and go to state 129
    LPAREN          shift and go to state 130

    rexp                           shift and go to state 172
    aexp                           shift and go to state 118
    mexp                           shift and go to state 119
    sexp                           shift and go to state 121
    pexp                           shift and go to state 128

state 146

    (40) rexp -> rexp LTHAN . aexp
    (44) aexp -> . aexp PLUS mexp
    (45) aexp -> . aexp MINUS mexp
    (46) aexp -> . mexp
    (47) mexp -> . mexp TIMES sexp
    (48) mexp -> . sexp
    (49) sexp -> . NOT sexp
    (50) sexp -> . MINUS sexp
    (51) sexp -> . TRUE
    (52) sexp -> . FALSE
    (53) sexp -> . NUMBER
    (54) sexp -> . NULL
    (55) sexp -> . NEW INT LBRACKET exp RBRACKET
    (56) sexp -> . pexp DOT LENGTH
    (57) sexp -> . ID DOT LENGTH
    (58) sexp -> . pexp LBRACKET exp RBRACKET
    (59) sexp -> . ID LBRACKET exp RBRACKET
    (60) sexp -> . ID
    (61) pexp -> . THIS
    (62) pexp -> . NEW ID LPAREN RPAREN
    (63) pexp -> . LPAREN exp RPAREN
    (64) pexp -> . pexp DOT ID
    (65) pexp -> . ID DOT ID
    (66) pexp -> . pexp DOT ID LPAREN exps RPAREN
    (67) pexp -> . pexp DOT ID LPAREN RPAREN
    (68) pexp -> . ID DOT ID LPAREN exps RPAREN
    (69) pexp -> . ID DOT ID LPAREN RPAREN

    NOT             shift and go to state 122
    MINUS           shift and go to state 120
    TRUE            shift and go to state 123
    FALSE           shift and go to state 124
    NUMBER          shift and go to state 125
    NULL            shift and go to state 126
    NEW             shift and go to state 127
    ID              shift and go to state 114
    THIS            shift and go to state 129
    LPAREN          shift and go to state 130

    aexp                           shift and go to state 173
    mexp                           shift and go to state 119
    sexp                           shift and go to state 121
    pexp                           shift and go to state 128

state 147

    (41) rexp -> rexp EQUALS . aexp
    (44) aexp -> . aexp PLUS mexp
    (45) aexp -> . aexp MINUS mexp
    (46) aexp -> . mexp
    (47) mexp -> . mexp TIMES sexp
    (48) mexp -> . sexp
    (49) sexp -> . NOT sexp
    (50) sexp -> . MINUS sexp
    (51) sexp -> . TRUE
    (52) sexp -> . FALSE
    (53) sexp -> . NUMBER
    (54) sexp -> . NULL
    (55) sexp -> . NEW INT LBRACKET exp RBRACKET
    (56) sexp -> . pexp DOT LENGTH
    (57) sexp -> . ID DOT LENGTH
    (58) sexp -> . pexp LBRACKET exp RBRACKET
    (59) sexp -> . ID LBRACKET exp RBRACKET
    (60) sexp -> . ID
    (61) pexp -> . THIS
    (62) pexp -> . NEW ID LPAREN RPAREN
    (63) pexp -> . LPAREN exp RPAREN
    (64) pexp -> . pexp DOT ID
    (65) pexp -> . ID DOT ID
    (66) pexp -> . pexp DOT ID LPAREN exps RPAREN
    (67) pexp -> . pexp DOT ID LPAREN RPAREN
    (68) pexp -> . ID DOT ID LPAREN exps RPAREN
    (69) pexp -> . ID DOT ID LPAREN RPAREN

    NOT             shift and go to state 122
    MINUS           shift and go to state 120
    TRUE            shift and go to state 123
    FALSE           shift and go to state 124
    NUMBER          shift and go to state 125
    NULL            shift and go to state 126
    NEW             shift and go to state 127
    ID              shift and go to state 114
    THIS            shift and go to state 129
    LPAREN          shift and go to state 130

    aexp                           shift and go to state 174
    mexp                           shift and go to state 119
    sexp                           shift and go to state 121
    pexp                           shift and go to state 128

state 148

    (42) rexp -> rexp DIFFERENT . aexp
    (44) aexp -> . aexp PLUS mexp
    (45) aexp -> . aexp MINUS mexp
    (46) aexp -> . mexp
    (47) mexp -> . mexp TIMES sexp
    (48) mexp -> . sexp
    (49) sexp -> . NOT sexp
    (50) sexp -> . MINUS sexp
    (51) sexp -> . TRUE
    (52) sexp -> . FALSE
    (53) sexp -> . NUMBER
    (54) sexp -> . NULL
    (55) sexp -> . NEW INT LBRACKET exp RBRACKET
    (56) sexp -> . pexp DOT LENGTH
    (57) sexp -> . ID DOT LENGTH
    (58) sexp -> . pexp LBRACKET exp RBRACKET
    (59) sexp -> . ID LBRACKET exp RBRACKET
    (60) sexp -> . ID
    (61) pexp -> . THIS
    (62) pexp -> . NEW ID LPAREN RPAREN
    (63) pexp -> . LPAREN exp RPAREN
    (64) pexp -> . pexp DOT ID
    (65) pexp -> . ID DOT ID
    (66) pexp -> . pexp DOT ID LPAREN exps RPAREN
    (67) pexp -> . pexp DOT ID LPAREN RPAREN
    (68) pexp -> . ID DOT ID LPAREN exps RPAREN
    (69) pexp -> . ID DOT ID LPAREN RPAREN

    NOT             shift and go to state 122
    MINUS           shift and go to state 120
    TRUE            shift and go to state 123
    FALSE           shift and go to state 124
    NUMBER          shift and go to state 125
    NULL            shift and go to state 126
    NEW             shift and go to state 127
    ID              shift and go to state 114
    THIS            shift and go to state 129
    LPAREN          shift and go to state 130

    aexp                           shift and go to state 175
    mexp                           shift and go to state 119
    sexp                           shift and go to state 121
    pexp                           shift and go to state 128

state 149

    (44) aexp -> aexp PLUS . mexp
    (47) mexp -> . mexp TIMES sexp
    (48) mexp -> . sexp
    (49) sexp -> . NOT sexp
    (50) sexp -> . MINUS sexp
    (51) sexp -> . TRUE
    (52) sexp -> . FALSE
    (53) sexp -> . NUMBER
    (54) sexp -> . NULL
    (55) sexp -> . NEW INT LBRACKET exp RBRACKET
    (56) sexp -> . pexp DOT LENGTH
    (57) sexp -> . ID DOT LENGTH
    (58) sexp -> . pexp LBRACKET exp RBRACKET
    (59) sexp -> . ID LBRACKET exp RBRACKET
    (60) sexp -> . ID
    (61) pexp -> . THIS
    (62) pexp -> . NEW ID LPAREN RPAREN
    (63) pexp -> . LPAREN exp RPAREN
    (64) pexp -> . pexp DOT ID
    (65) pexp -> . ID DOT ID
    (66) pexp -> . pexp DOT ID LPAREN exps RPAREN
    (67) pexp -> . pexp DOT ID LPAREN RPAREN
    (68) pexp -> . ID DOT ID LPAREN exps RPAREN
    (69) pexp -> . ID DOT ID LPAREN RPAREN

    NOT             shift and go to state 122
    MINUS           shift and go to state 120
    TRUE            shift and go to state 123
    FALSE           shift and go to state 124
    NUMBER          shift and go to state 125
    NULL            shift and go to state 126
    NEW             shift and go to state 127
    ID              shift and go to state 114
    THIS            shift and go to state 129
    LPAREN          shift and go to state 130

    mexp                           shift and go to state 176
    sexp                           shift and go to state 121
    pexp                           shift and go to state 128

state 150

    (45) aexp -> aexp MINUS . mexp
    (47) mexp -> . mexp TIMES sexp
    (48) mexp -> . sexp
    (49) sexp -> . NOT sexp
    (50) sexp -> . MINUS sexp
    (51) sexp -> . TRUE
    (52) sexp -> . FALSE
    (53) sexp -> . NUMBER
    (54) sexp -> . NULL
    (55) sexp -> . NEW INT LBRACKET exp RBRACKET
    (56) sexp -> . pexp DOT LENGTH
    (57) sexp -> . ID DOT LENGTH
    (58) sexp -> . pexp LBRACKET exp RBRACKET
    (59) sexp -> . ID LBRACKET exp RBRACKET
    (60) sexp -> . ID
    (61) pexp -> . THIS
    (62) pexp -> . NEW ID LPAREN RPAREN
    (63) pexp -> . LPAREN exp RPAREN
    (64) pexp -> . pexp DOT ID
    (65) pexp -> . ID DOT ID
    (66) pexp -> . pexp DOT ID LPAREN exps RPAREN
    (67) pexp -> . pexp DOT ID LPAREN RPAREN
    (68) pexp -> . ID DOT ID LPAREN exps RPAREN
    (69) pexp -> . ID DOT ID LPAREN RPAREN

    NOT             shift and go to state 122
    MINUS           shift and go to state 120
    TRUE            shift and go to state 123
    FALSE           shift and go to state 124
    NUMBER          shift and go to state 125
    NULL            shift and go to state 126
    NEW             shift and go to state 127
    ID              shift and go to state 114
    THIS            shift and go to state 129
    LPAREN          shift and go to state 130

    mexp                           shift and go to state 177
    sexp                           shift and go to state 121
    pexp                           shift and go to state 128

state 151

    (47) mexp -> mexp TIMES . sexp
    (49) sexp -> . NOT sexp
    (50) sexp -> . MINUS sexp
    (51) sexp -> . TRUE
    (52) sexp -> . FALSE
    (53) sexp -> . NUMBER
    (54) sexp -> . NULL
    (55) sexp -> . NEW INT LBRACKET exp RBRACKET
    (56) sexp -> . pexp DOT LENGTH
    (57) sexp -> . ID DOT LENGTH
    (58) sexp -> . pexp LBRACKET exp RBRACKET
    (59) sexp -> . ID LBRACKET exp RBRACKET
    (60) sexp -> . ID
    (61) pexp -> . THIS
    (62) pexp -> . NEW ID LPAREN RPAREN
    (63) pexp -> . LPAREN exp RPAREN
    (64) pexp -> . pexp DOT ID
    (65) pexp -> . ID DOT ID
    (66) pexp -> . pexp DOT ID LPAREN exps RPAREN
    (67) pexp -> . pexp DOT ID LPAREN RPAREN
    (68) pexp -> . ID DOT ID LPAREN exps RPAREN
    (69) pexp -> . ID DOT ID LPAREN RPAREN

    NOT             shift and go to state 122
    MINUS           shift and go to state 120
    TRUE            shift and go to state 123
    FALSE           shift and go to state 124
    NUMBER          shift and go to state 125
    NULL            shift and go to state 126
    NEW             shift and go to state 127
    ID              shift and go to state 114
    THIS            shift and go to state 129
    LPAREN          shift and go to state 130

    sexp                           shift and go to state 178
    pexp                           shift and go to state 128

state 152

    (50) sexp -> MINUS sexp .

    SEMICOLON       reduce using rule 50 (sexp -> MINUS sexp .)
    RPAREN          reduce using rule 50 (sexp -> MINUS sexp .)
    RBRACKET        reduce using rule 50 (sexp -> MINUS sexp .)
    AND             reduce using rule 50 (sexp -> MINUS sexp .)
    LTHAN           reduce using rule 50 (sexp -> MINUS sexp .)
    EQUALS          reduce using rule 50 (sexp -> MINUS sexp .)
    DIFFERENT       reduce using rule 50 (sexp -> MINUS sexp .)
    PLUS            reduce using rule 50 (sexp -> MINUS sexp .)
    MINUS           reduce using rule 50 (sexp -> MINUS sexp .)
    TIMES           reduce using rule 50 (sexp -> MINUS sexp .)
    COMMA           reduce using rule 50 (sexp -> MINUS sexp .)


state 153

    (49) sexp -> NOT sexp .

    SEMICOLON       reduce using rule 49 (sexp -> NOT sexp .)
    RPAREN          reduce using rule 49 (sexp -> NOT sexp .)
    RBRACKET        reduce using rule 49 (sexp -> NOT sexp .)
    AND             reduce using rule 49 (sexp -> NOT sexp .)
    LTHAN           reduce using rule 49 (sexp -> NOT sexp .)
    EQUALS          reduce using rule 49 (sexp -> NOT sexp .)
    DIFFERENT       reduce using rule 49 (sexp -> NOT sexp .)
    PLUS            reduce using rule 49 (sexp -> NOT sexp .)
    MINUS           reduce using rule 49 (sexp -> NOT sexp .)
    TIMES           reduce using rule 49 (sexp -> NOT sexp .)
    COMMA           reduce using rule 49 (sexp -> NOT sexp .)


state 154

    (55) sexp -> NEW INT . LBRACKET exp RBRACKET

    LBRACKET        shift and go to state 179


state 155

    (62) pexp -> NEW ID . LPAREN RPAREN

    LPAREN          shift and go to state 180


state 156

    (56) sexp -> pexp DOT . LENGTH
    (64) pexp -> pexp DOT . ID
    (66) pexp -> pexp DOT . ID LPAREN exps RPAREN
    (67) pexp -> pexp DOT . ID LPAREN RPAREN

    LENGTH          shift and go to state 181
    ID              shift and go to state 182


state 157

    (58) sexp -> pexp LBRACKET . exp RBRACKET
    (37) exp -> . exp AND rexp
    (38) exp -> . rexp
    (39) exp -> . empty
    (40) rexp -> . rexp LTHAN aexp
    (41) rexp -> . rexp EQUALS aexp
    (42) rexp -> . rexp DIFFERENT aexp
    (43) rexp -> . aexp
    (72) empty -> .
    (44) aexp -> . aexp PLUS mexp
    (45) aexp -> . aexp MINUS mexp
    (46) aexp -> . mexp
    (47) mexp -> . mexp TIMES sexp
    (48) mexp -> . sexp
    (49) sexp -> . NOT sexp
    (50) sexp -> . MINUS sexp
    (51) sexp -> . TRUE
    (52) sexp -> . FALSE
    (53) sexp -> . NUMBER
    (54) sexp -> . NULL
    (55) sexp -> . NEW INT LBRACKET exp RBRACKET
    (56) sexp -> . pexp DOT LENGTH
    (57) sexp -> . ID DOT LENGTH
    (58) sexp -> . pexp LBRACKET exp RBRACKET
    (59) sexp -> . ID LBRACKET exp RBRACKET
    (60) sexp -> . ID
    (61) pexp -> . THIS
    (62) pexp -> . NEW ID LPAREN RPAREN
    (63) pexp -> . LPAREN exp RPAREN
    (64) pexp -> . pexp DOT ID
    (65) pexp -> . ID DOT ID
    (66) pexp -> . pexp DOT ID LPAREN exps RPAREN
    (67) pexp -> . pexp DOT ID LPAREN RPAREN
    (68) pexp -> . ID DOT ID LPAREN exps RPAREN
    (69) pexp -> . ID DOT ID LPAREN RPAREN

  ! shift/reduce conflict for ID resolved as shift
    PUBLIC          reduce using rule 72 (empty -> .)
    RCURLY          reduce using rule 72 (empty -> .)
    INT             reduce using rule 72 (empty -> .)
    BOOLEAN         reduce using rule 72 (empty -> .)
    RETURN          reduce using rule 72 (empty -> .)
    LCURLY          reduce using rule 72 (empty -> .)
    IF              reduce using rule 72 (empty -> .)
    WHILE           reduce using rule 72 (empty -> .)
    PRINTLN         reduce using rule 72 (empty -> .)
    ELSE            reduce using rule 72 (empty -> .)
    SEMICOLON       reduce using rule 72 (empty -> .)
    RPAREN          reduce using rule 72 (empty -> .)
    RBRACKET        reduce using rule 72 (empty -> .)
    AND             reduce using rule 72 (empty -> .)
    COMMA           reduce using rule 72 (empty -> .)
    NOT             shift and go to state 122
    MINUS           shift and go to state 120
    TRUE            shift and go to state 123
    FALSE           shift and go to state 124
    NUMBER          shift and go to state 125
    NULL            shift and go to state 126
    NEW             shift and go to state 127
    ID              shift and go to state 114
    THIS            shift and go to state 129
    LPAREN          shift and go to state 130

  ! ID              [ reduce using rule 72 (empty -> .) ]

    pexp                           shift and go to state 128
    exp                            shift and go to state 183
    rexp                           shift and go to state 116
    empty                          shift and go to state 117
    aexp                           shift and go to state 118
    mexp                           shift and go to state 119
    sexp                           shift and go to state 121

state 158

    (63) pexp -> LPAREN exp . RPAREN
    (37) exp -> exp . AND rexp

    RPAREN          shift and go to state 184
    AND             shift and go to state 145


state 159

    (35) cmd -> ID LBRACKET exp RBRACKET . ASSIGN exp SEMICOLON

    ASSIGN          shift and go to state 185


state 160

    (16) metodo -> PUBLIC tipo ID LPAREN RPAREN LCURLY vars cmds RETURN exp SEMICOLON . RCURLY

    RCURLY          shift and go to state 186


state 161

    (30) cmd -> IF LPAREN exp RPAREN . cmd
    (31) cmd -> IF LPAREN exp RPAREN . cmd ELSE cmd
    (29) cmd -> . LCURLY cmds RCURLY
    (30) cmd -> . IF LPAREN exp RPAREN cmd
    (31) cmd -> . IF LPAREN exp RPAREN cmd ELSE cmd
    (32) cmd -> . WHILE LPAREN exp RPAREN cmd
    (33) cmd -> . PRINTLN LPAREN exp RPAREN SEMICOLON
    (34) cmd -> . ID ASSIGN exp SEMICOLON
    (35) cmd -> . ID LBRACKET exp RBRACKET ASSIGN exp SEMICOLON
    (36) cmd -> . empty
    (72) empty -> .

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for LCURLY resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for PRINTLN resolved as shift
    LCURLY          shift and go to state 88
    IF              shift and go to state 91
    WHILE           shift and go to state 92
    PRINTLN         shift and go to state 93
    ID              shift and go to state 103
    PUBLIC          reduce using rule 72 (empty -> .)
    RCURLY          reduce using rule 72 (empty -> .)
    INT             reduce using rule 72 (empty -> .)
    BOOLEAN         reduce using rule 72 (empty -> .)
    RETURN          reduce using rule 72 (empty -> .)
    ELSE            reduce using rule 72 (empty -> .)
    SEMICOLON       reduce using rule 72 (empty -> .)
    RPAREN          reduce using rule 72 (empty -> .)
    RBRACKET        reduce using rule 72 (empty -> .)
    AND             reduce using rule 72 (empty -> .)
    COMMA           reduce using rule 72 (empty -> .)

  ! ID              [ reduce using rule 72 (empty -> .) ]
  ! LCURLY          [ reduce using rule 72 (empty -> .) ]
  ! IF              [ reduce using rule 72 (empty -> .) ]
  ! WHILE           [ reduce using rule 72 (empty -> .) ]
  ! PRINTLN         [ reduce using rule 72 (empty -> .) ]

    cmd                            shift and go to state 187
    empty                          shift and go to state 94

state 162

    (32) cmd -> WHILE LPAREN exp RPAREN . cmd
    (29) cmd -> . LCURLY cmds RCURLY
    (30) cmd -> . IF LPAREN exp RPAREN cmd
    (31) cmd -> . IF LPAREN exp RPAREN cmd ELSE cmd
    (32) cmd -> . WHILE LPAREN exp RPAREN cmd
    (33) cmd -> . PRINTLN LPAREN exp RPAREN SEMICOLON
    (34) cmd -> . ID ASSIGN exp SEMICOLON
    (35) cmd -> . ID LBRACKET exp RBRACKET ASSIGN exp SEMICOLON
    (36) cmd -> . empty
    (72) empty -> .

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for LCURLY resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for PRINTLN resolved as shift
    LCURLY          shift and go to state 88
    IF              shift and go to state 91
    WHILE           shift and go to state 92
    PRINTLN         shift and go to state 93
    ID              shift and go to state 103
    PUBLIC          reduce using rule 72 (empty -> .)
    RCURLY          reduce using rule 72 (empty -> .)
    INT             reduce using rule 72 (empty -> .)
    BOOLEAN         reduce using rule 72 (empty -> .)
    RETURN          reduce using rule 72 (empty -> .)
    ELSE            reduce using rule 72 (empty -> .)
    SEMICOLON       reduce using rule 72 (empty -> .)
    RPAREN          reduce using rule 72 (empty -> .)
    RBRACKET        reduce using rule 72 (empty -> .)
    AND             reduce using rule 72 (empty -> .)
    COMMA           reduce using rule 72 (empty -> .)

  ! ID              [ reduce using rule 72 (empty -> .) ]
  ! LCURLY          [ reduce using rule 72 (empty -> .) ]
  ! IF              [ reduce using rule 72 (empty -> .) ]
  ! WHILE           [ reduce using rule 72 (empty -> .) ]
  ! PRINTLN         [ reduce using rule 72 (empty -> .) ]

    cmd                            shift and go to state 188
    empty                          shift and go to state 94

state 163

    (33) cmd -> PRINTLN LPAREN exp RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 189


state 164

    (17) metodo -> PUBLIC ID ID LPAREN params RPAREN LCURLY vars cmds RETURN exp . SEMICOLON RCURLY
    (37) exp -> exp . AND rexp

    SEMICOLON       shift and go to state 190
    AND             shift and go to state 145


state 165

    (18) metodo -> PUBLIC ID ID LPAREN RPAREN LCURLY vars cmds RETURN exp SEMICOLON . RCURLY

    RCURLY          shift and go to state 191


state 166

    (2) main -> CLASS ID LCURLY PUBLIC STATIC VOID MAIN LPAREN STRING LBRACKET RBRACKET ID RPAREN LCURLY cmd RCURLY . RCURLY

    RCURLY          shift and go to state 192


state 167

    (3) main -> ID LCURLY PUBLIC STATIC VOID MAIN LPAREN STRING LBRACKET RBRACKET ID RPAREN LCURLY cmd RCURLY RCURLY .

    CLASS           reduce using rule 3 (main -> ID LCURLY PUBLIC STATIC VOID MAIN LPAREN STRING LBRACKET RBRACKET ID RPAREN LCURLY cmd RCURLY RCURLY .)


state 168

    (15) metodo -> PUBLIC tipo ID LPAREN params RPAREN LCURLY vars cmds RETURN exp SEMICOLON . RCURLY

    RCURLY          shift and go to state 193


state 169

    (65) pexp -> ID DOT ID .
    (68) pexp -> ID DOT ID . LPAREN exps RPAREN
    (69) pexp -> ID DOT ID . LPAREN RPAREN

    DOT             reduce using rule 65 (pexp -> ID DOT ID .)
    LBRACKET        reduce using rule 65 (pexp -> ID DOT ID .)
    LPAREN          shift and go to state 194


state 170

    (57) sexp -> ID DOT LENGTH .

    SEMICOLON       reduce using rule 57 (sexp -> ID DOT LENGTH .)
    RPAREN          reduce using rule 57 (sexp -> ID DOT LENGTH .)
    RBRACKET        reduce using rule 57 (sexp -> ID DOT LENGTH .)
    AND             reduce using rule 57 (sexp -> ID DOT LENGTH .)
    LTHAN           reduce using rule 57 (sexp -> ID DOT LENGTH .)
    EQUALS          reduce using rule 57 (sexp -> ID DOT LENGTH .)
    DIFFERENT       reduce using rule 57 (sexp -> ID DOT LENGTH .)
    PLUS            reduce using rule 57 (sexp -> ID DOT LENGTH .)
    MINUS           reduce using rule 57 (sexp -> ID DOT LENGTH .)
    TIMES           reduce using rule 57 (sexp -> ID DOT LENGTH .)
    COMMA           reduce using rule 57 (sexp -> ID DOT LENGTH .)


state 171

    (59) sexp -> ID LBRACKET exp . RBRACKET
    (37) exp -> exp . AND rexp

    RBRACKET        shift and go to state 195
    AND             shift and go to state 145


state 172

    (37) exp -> exp AND rexp .
    (40) rexp -> rexp . LTHAN aexp
    (41) rexp -> rexp . EQUALS aexp
    (42) rexp -> rexp . DIFFERENT aexp

    SEMICOLON       reduce using rule 37 (exp -> exp AND rexp .)
    RPAREN          reduce using rule 37 (exp -> exp AND rexp .)
    RBRACKET        reduce using rule 37 (exp -> exp AND rexp .)
    AND             reduce using rule 37 (exp -> exp AND rexp .)
    COMMA           reduce using rule 37 (exp -> exp AND rexp .)
    LTHAN           shift and go to state 146
    EQUALS          shift and go to state 147
    DIFFERENT       shift and go to state 148


state 173

    (40) rexp -> rexp LTHAN aexp .
    (44) aexp -> aexp . PLUS mexp
    (45) aexp -> aexp . MINUS mexp

    SEMICOLON       reduce using rule 40 (rexp -> rexp LTHAN aexp .)
    RPAREN          reduce using rule 40 (rexp -> rexp LTHAN aexp .)
    RBRACKET        reduce using rule 40 (rexp -> rexp LTHAN aexp .)
    AND             reduce using rule 40 (rexp -> rexp LTHAN aexp .)
    LTHAN           reduce using rule 40 (rexp -> rexp LTHAN aexp .)
    EQUALS          reduce using rule 40 (rexp -> rexp LTHAN aexp .)
    DIFFERENT       reduce using rule 40 (rexp -> rexp LTHAN aexp .)
    COMMA           reduce using rule 40 (rexp -> rexp LTHAN aexp .)
    PLUS            shift and go to state 149
    MINUS           shift and go to state 150


state 174

    (41) rexp -> rexp EQUALS aexp .
    (44) aexp -> aexp . PLUS mexp
    (45) aexp -> aexp . MINUS mexp

    SEMICOLON       reduce using rule 41 (rexp -> rexp EQUALS aexp .)
    RPAREN          reduce using rule 41 (rexp -> rexp EQUALS aexp .)
    RBRACKET        reduce using rule 41 (rexp -> rexp EQUALS aexp .)
    AND             reduce using rule 41 (rexp -> rexp EQUALS aexp .)
    LTHAN           reduce using rule 41 (rexp -> rexp EQUALS aexp .)
    EQUALS          reduce using rule 41 (rexp -> rexp EQUALS aexp .)
    DIFFERENT       reduce using rule 41 (rexp -> rexp EQUALS aexp .)
    COMMA           reduce using rule 41 (rexp -> rexp EQUALS aexp .)
    PLUS            shift and go to state 149
    MINUS           shift and go to state 150


state 175

    (42) rexp -> rexp DIFFERENT aexp .
    (44) aexp -> aexp . PLUS mexp
    (45) aexp -> aexp . MINUS mexp

    SEMICOLON       reduce using rule 42 (rexp -> rexp DIFFERENT aexp .)
    RPAREN          reduce using rule 42 (rexp -> rexp DIFFERENT aexp .)
    RBRACKET        reduce using rule 42 (rexp -> rexp DIFFERENT aexp .)
    AND             reduce using rule 42 (rexp -> rexp DIFFERENT aexp .)
    LTHAN           reduce using rule 42 (rexp -> rexp DIFFERENT aexp .)
    EQUALS          reduce using rule 42 (rexp -> rexp DIFFERENT aexp .)
    DIFFERENT       reduce using rule 42 (rexp -> rexp DIFFERENT aexp .)
    COMMA           reduce using rule 42 (rexp -> rexp DIFFERENT aexp .)
    PLUS            shift and go to state 149
    MINUS           shift and go to state 150


state 176

    (44) aexp -> aexp PLUS mexp .
    (47) mexp -> mexp . TIMES sexp

    SEMICOLON       reduce using rule 44 (aexp -> aexp PLUS mexp .)
    RPAREN          reduce using rule 44 (aexp -> aexp PLUS mexp .)
    RBRACKET        reduce using rule 44 (aexp -> aexp PLUS mexp .)
    AND             reduce using rule 44 (aexp -> aexp PLUS mexp .)
    LTHAN           reduce using rule 44 (aexp -> aexp PLUS mexp .)
    EQUALS          reduce using rule 44 (aexp -> aexp PLUS mexp .)
    DIFFERENT       reduce using rule 44 (aexp -> aexp PLUS mexp .)
    PLUS            reduce using rule 44 (aexp -> aexp PLUS mexp .)
    MINUS           reduce using rule 44 (aexp -> aexp PLUS mexp .)
    COMMA           reduce using rule 44 (aexp -> aexp PLUS mexp .)
    TIMES           shift and go to state 151


state 177

    (45) aexp -> aexp MINUS mexp .
    (47) mexp -> mexp . TIMES sexp

    SEMICOLON       reduce using rule 45 (aexp -> aexp MINUS mexp .)
    RPAREN          reduce using rule 45 (aexp -> aexp MINUS mexp .)
    RBRACKET        reduce using rule 45 (aexp -> aexp MINUS mexp .)
    AND             reduce using rule 45 (aexp -> aexp MINUS mexp .)
    LTHAN           reduce using rule 45 (aexp -> aexp MINUS mexp .)
    EQUALS          reduce using rule 45 (aexp -> aexp MINUS mexp .)
    DIFFERENT       reduce using rule 45 (aexp -> aexp MINUS mexp .)
    PLUS            reduce using rule 45 (aexp -> aexp MINUS mexp .)
    MINUS           reduce using rule 45 (aexp -> aexp MINUS mexp .)
    COMMA           reduce using rule 45 (aexp -> aexp MINUS mexp .)
    TIMES           shift and go to state 151


state 178

    (47) mexp -> mexp TIMES sexp .

    SEMICOLON       reduce using rule 47 (mexp -> mexp TIMES sexp .)
    RPAREN          reduce using rule 47 (mexp -> mexp TIMES sexp .)
    RBRACKET        reduce using rule 47 (mexp -> mexp TIMES sexp .)
    AND             reduce using rule 47 (mexp -> mexp TIMES sexp .)
    LTHAN           reduce using rule 47 (mexp -> mexp TIMES sexp .)
    EQUALS          reduce using rule 47 (mexp -> mexp TIMES sexp .)
    DIFFERENT       reduce using rule 47 (mexp -> mexp TIMES sexp .)
    PLUS            reduce using rule 47 (mexp -> mexp TIMES sexp .)
    MINUS           reduce using rule 47 (mexp -> mexp TIMES sexp .)
    TIMES           reduce using rule 47 (mexp -> mexp TIMES sexp .)
    COMMA           reduce using rule 47 (mexp -> mexp TIMES sexp .)


state 179

    (55) sexp -> NEW INT LBRACKET . exp RBRACKET
    (37) exp -> . exp AND rexp
    (38) exp -> . rexp
    (39) exp -> . empty
    (40) rexp -> . rexp LTHAN aexp
    (41) rexp -> . rexp EQUALS aexp
    (42) rexp -> . rexp DIFFERENT aexp
    (43) rexp -> . aexp
    (72) empty -> .
    (44) aexp -> . aexp PLUS mexp
    (45) aexp -> . aexp MINUS mexp
    (46) aexp -> . mexp
    (47) mexp -> . mexp TIMES sexp
    (48) mexp -> . sexp
    (49) sexp -> . NOT sexp
    (50) sexp -> . MINUS sexp
    (51) sexp -> . TRUE
    (52) sexp -> . FALSE
    (53) sexp -> . NUMBER
    (54) sexp -> . NULL
    (55) sexp -> . NEW INT LBRACKET exp RBRACKET
    (56) sexp -> . pexp DOT LENGTH
    (57) sexp -> . ID DOT LENGTH
    (58) sexp -> . pexp LBRACKET exp RBRACKET
    (59) sexp -> . ID LBRACKET exp RBRACKET
    (60) sexp -> . ID
    (61) pexp -> . THIS
    (62) pexp -> . NEW ID LPAREN RPAREN
    (63) pexp -> . LPAREN exp RPAREN
    (64) pexp -> . pexp DOT ID
    (65) pexp -> . ID DOT ID
    (66) pexp -> . pexp DOT ID LPAREN exps RPAREN
    (67) pexp -> . pexp DOT ID LPAREN RPAREN
    (68) pexp -> . ID DOT ID LPAREN exps RPAREN
    (69) pexp -> . ID DOT ID LPAREN RPAREN

  ! shift/reduce conflict for ID resolved as shift
    PUBLIC          reduce using rule 72 (empty -> .)
    RCURLY          reduce using rule 72 (empty -> .)
    INT             reduce using rule 72 (empty -> .)
    BOOLEAN         reduce using rule 72 (empty -> .)
    RETURN          reduce using rule 72 (empty -> .)
    LCURLY          reduce using rule 72 (empty -> .)
    IF              reduce using rule 72 (empty -> .)
    WHILE           reduce using rule 72 (empty -> .)
    PRINTLN         reduce using rule 72 (empty -> .)
    ELSE            reduce using rule 72 (empty -> .)
    SEMICOLON       reduce using rule 72 (empty -> .)
    RPAREN          reduce using rule 72 (empty -> .)
    RBRACKET        reduce using rule 72 (empty -> .)
    AND             reduce using rule 72 (empty -> .)
    COMMA           reduce using rule 72 (empty -> .)
    NOT             shift and go to state 122
    MINUS           shift and go to state 120
    TRUE            shift and go to state 123
    FALSE           shift and go to state 124
    NUMBER          shift and go to state 125
    NULL            shift and go to state 126
    NEW             shift and go to state 127
    ID              shift and go to state 114
    THIS            shift and go to state 129
    LPAREN          shift and go to state 130

  ! ID              [ reduce using rule 72 (empty -> .) ]

    exp                            shift and go to state 196
    rexp                           shift and go to state 116
    empty                          shift and go to state 117
    aexp                           shift and go to state 118
    mexp                           shift and go to state 119
    sexp                           shift and go to state 121
    pexp                           shift and go to state 128

state 180

    (62) pexp -> NEW ID LPAREN . RPAREN

    RPAREN          shift and go to state 197


state 181

    (56) sexp -> pexp DOT LENGTH .

    SEMICOLON       reduce using rule 56 (sexp -> pexp DOT LENGTH .)
    RPAREN          reduce using rule 56 (sexp -> pexp DOT LENGTH .)
    RBRACKET        reduce using rule 56 (sexp -> pexp DOT LENGTH .)
    AND             reduce using rule 56 (sexp -> pexp DOT LENGTH .)
    LTHAN           reduce using rule 56 (sexp -> pexp DOT LENGTH .)
    EQUALS          reduce using rule 56 (sexp -> pexp DOT LENGTH .)
    DIFFERENT       reduce using rule 56 (sexp -> pexp DOT LENGTH .)
    PLUS            reduce using rule 56 (sexp -> pexp DOT LENGTH .)
    MINUS           reduce using rule 56 (sexp -> pexp DOT LENGTH .)
    TIMES           reduce using rule 56 (sexp -> pexp DOT LENGTH .)
    COMMA           reduce using rule 56 (sexp -> pexp DOT LENGTH .)


state 182

    (64) pexp -> pexp DOT ID .
    (66) pexp -> pexp DOT ID . LPAREN exps RPAREN
    (67) pexp -> pexp DOT ID . LPAREN RPAREN

    DOT             reduce using rule 64 (pexp -> pexp DOT ID .)
    LBRACKET        reduce using rule 64 (pexp -> pexp DOT ID .)
    LPAREN          shift and go to state 198


state 183

    (58) sexp -> pexp LBRACKET exp . RBRACKET
    (37) exp -> exp . AND rexp

    RBRACKET        shift and go to state 199
    AND             shift and go to state 145


state 184

    (63) pexp -> LPAREN exp RPAREN .

    DOT             reduce using rule 63 (pexp -> LPAREN exp RPAREN .)
    LBRACKET        reduce using rule 63 (pexp -> LPAREN exp RPAREN .)


state 185

    (35) cmd -> ID LBRACKET exp RBRACKET ASSIGN . exp SEMICOLON
    (37) exp -> . exp AND rexp
    (38) exp -> . rexp
    (39) exp -> . empty
    (40) rexp -> . rexp LTHAN aexp
    (41) rexp -> . rexp EQUALS aexp
    (42) rexp -> . rexp DIFFERENT aexp
    (43) rexp -> . aexp
    (72) empty -> .
    (44) aexp -> . aexp PLUS mexp
    (45) aexp -> . aexp MINUS mexp
    (46) aexp -> . mexp
    (47) mexp -> . mexp TIMES sexp
    (48) mexp -> . sexp
    (49) sexp -> . NOT sexp
    (50) sexp -> . MINUS sexp
    (51) sexp -> . TRUE
    (52) sexp -> . FALSE
    (53) sexp -> . NUMBER
    (54) sexp -> . NULL
    (55) sexp -> . NEW INT LBRACKET exp RBRACKET
    (56) sexp -> . pexp DOT LENGTH
    (57) sexp -> . ID DOT LENGTH
    (58) sexp -> . pexp LBRACKET exp RBRACKET
    (59) sexp -> . ID LBRACKET exp RBRACKET
    (60) sexp -> . ID
    (61) pexp -> . THIS
    (62) pexp -> . NEW ID LPAREN RPAREN
    (63) pexp -> . LPAREN exp RPAREN
    (64) pexp -> . pexp DOT ID
    (65) pexp -> . ID DOT ID
    (66) pexp -> . pexp DOT ID LPAREN exps RPAREN
    (67) pexp -> . pexp DOT ID LPAREN RPAREN
    (68) pexp -> . ID DOT ID LPAREN exps RPAREN
    (69) pexp -> . ID DOT ID LPAREN RPAREN

  ! shift/reduce conflict for ID resolved as shift
    PUBLIC          reduce using rule 72 (empty -> .)
    RCURLY          reduce using rule 72 (empty -> .)
    INT             reduce using rule 72 (empty -> .)
    BOOLEAN         reduce using rule 72 (empty -> .)
    RETURN          reduce using rule 72 (empty -> .)
    LCURLY          reduce using rule 72 (empty -> .)
    IF              reduce using rule 72 (empty -> .)
    WHILE           reduce using rule 72 (empty -> .)
    PRINTLN         reduce using rule 72 (empty -> .)
    ELSE            reduce using rule 72 (empty -> .)
    SEMICOLON       reduce using rule 72 (empty -> .)
    RPAREN          reduce using rule 72 (empty -> .)
    RBRACKET        reduce using rule 72 (empty -> .)
    AND             reduce using rule 72 (empty -> .)
    COMMA           reduce using rule 72 (empty -> .)
    NOT             shift and go to state 122
    MINUS           shift and go to state 120
    TRUE            shift and go to state 123
    FALSE           shift and go to state 124
    NUMBER          shift and go to state 125
    NULL            shift and go to state 126
    NEW             shift and go to state 127
    ID              shift and go to state 114
    THIS            shift and go to state 129
    LPAREN          shift and go to state 130

  ! ID              [ reduce using rule 72 (empty -> .) ]

    exp                            shift and go to state 200
    rexp                           shift and go to state 116
    empty                          shift and go to state 117
    aexp                           shift and go to state 118
    mexp                           shift and go to state 119
    sexp                           shift and go to state 121
    pexp                           shift and go to state 128

state 186

    (16) metodo -> PUBLIC tipo ID LPAREN RPAREN LCURLY vars cmds RETURN exp SEMICOLON RCURLY .

    RCURLY          reduce using rule 16 (metodo -> PUBLIC tipo ID LPAREN RPAREN LCURLY vars cmds RETURN exp SEMICOLON RCURLY .)
    PUBLIC          reduce using rule 16 (metodo -> PUBLIC tipo ID LPAREN RPAREN LCURLY vars cmds RETURN exp SEMICOLON RCURLY .)


state 187

    (30) cmd -> IF LPAREN exp RPAREN cmd .
    (31) cmd -> IF LPAREN exp RPAREN cmd . ELSE cmd

  ! shift/reduce conflict for ELSE resolved as shift
    RCURLY          reduce using rule 30 (cmd -> IF LPAREN exp RPAREN cmd .)
    RETURN          reduce using rule 30 (cmd -> IF LPAREN exp RPAREN cmd .)
    LCURLY          reduce using rule 30 (cmd -> IF LPAREN exp RPAREN cmd .)
    IF              reduce using rule 30 (cmd -> IF LPAREN exp RPAREN cmd .)
    WHILE           reduce using rule 30 (cmd -> IF LPAREN exp RPAREN cmd .)
    PRINTLN         reduce using rule 30 (cmd -> IF LPAREN exp RPAREN cmd .)
    ID              reduce using rule 30 (cmd -> IF LPAREN exp RPAREN cmd .)
    ELSE            shift and go to state 201

  ! ELSE            [ reduce using rule 30 (cmd -> IF LPAREN exp RPAREN cmd .) ]


state 188

    (32) cmd -> WHILE LPAREN exp RPAREN cmd .

    RCURLY          reduce using rule 32 (cmd -> WHILE LPAREN exp RPAREN cmd .)
    RETURN          reduce using rule 32 (cmd -> WHILE LPAREN exp RPAREN cmd .)
    LCURLY          reduce using rule 32 (cmd -> WHILE LPAREN exp RPAREN cmd .)
    IF              reduce using rule 32 (cmd -> WHILE LPAREN exp RPAREN cmd .)
    WHILE           reduce using rule 32 (cmd -> WHILE LPAREN exp RPAREN cmd .)
    PRINTLN         reduce using rule 32 (cmd -> WHILE LPAREN exp RPAREN cmd .)
    ID              reduce using rule 32 (cmd -> WHILE LPAREN exp RPAREN cmd .)
    ELSE            reduce using rule 32 (cmd -> WHILE LPAREN exp RPAREN cmd .)


state 189

    (33) cmd -> PRINTLN LPAREN exp RPAREN SEMICOLON .

    RCURLY          reduce using rule 33 (cmd -> PRINTLN LPAREN exp RPAREN SEMICOLON .)
    RETURN          reduce using rule 33 (cmd -> PRINTLN LPAREN exp RPAREN SEMICOLON .)
    LCURLY          reduce using rule 33 (cmd -> PRINTLN LPAREN exp RPAREN SEMICOLON .)
    IF              reduce using rule 33 (cmd -> PRINTLN LPAREN exp RPAREN SEMICOLON .)
    WHILE           reduce using rule 33 (cmd -> PRINTLN LPAREN exp RPAREN SEMICOLON .)
    PRINTLN         reduce using rule 33 (cmd -> PRINTLN LPAREN exp RPAREN SEMICOLON .)
    ID              reduce using rule 33 (cmd -> PRINTLN LPAREN exp RPAREN SEMICOLON .)
    ELSE            reduce using rule 33 (cmd -> PRINTLN LPAREN exp RPAREN SEMICOLON .)


state 190

    (17) metodo -> PUBLIC ID ID LPAREN params RPAREN LCURLY vars cmds RETURN exp SEMICOLON . RCURLY

    RCURLY          shift and go to state 202


state 191

    (18) metodo -> PUBLIC ID ID LPAREN RPAREN LCURLY vars cmds RETURN exp SEMICOLON RCURLY .

    RCURLY          reduce using rule 18 (metodo -> PUBLIC ID ID LPAREN RPAREN LCURLY vars cmds RETURN exp SEMICOLON RCURLY .)
    PUBLIC          reduce using rule 18 (metodo -> PUBLIC ID ID LPAREN RPAREN LCURLY vars cmds RETURN exp SEMICOLON RCURLY .)


state 192

    (2) main -> CLASS ID LCURLY PUBLIC STATIC VOID MAIN LPAREN STRING LBRACKET RBRACKET ID RPAREN LCURLY cmd RCURLY RCURLY .

    CLASS           reduce using rule 2 (main -> CLASS ID LCURLY PUBLIC STATIC VOID MAIN LPAREN STRING LBRACKET RBRACKET ID RPAREN LCURLY cmd RCURLY RCURLY .)


state 193

    (15) metodo -> PUBLIC tipo ID LPAREN params RPAREN LCURLY vars cmds RETURN exp SEMICOLON RCURLY .

    RCURLY          reduce using rule 15 (metodo -> PUBLIC tipo ID LPAREN params RPAREN LCURLY vars cmds RETURN exp SEMICOLON RCURLY .)
    PUBLIC          reduce using rule 15 (metodo -> PUBLIC tipo ID LPAREN params RPAREN LCURLY vars cmds RETURN exp SEMICOLON RCURLY .)


state 194

    (68) pexp -> ID DOT ID LPAREN . exps RPAREN
    (69) pexp -> ID DOT ID LPAREN . RPAREN
    (70) exps -> . exp
    (71) exps -> . exps COMMA exp
    (37) exp -> . exp AND rexp
    (38) exp -> . rexp
    (39) exp -> . empty
    (40) rexp -> . rexp LTHAN aexp
    (41) rexp -> . rexp EQUALS aexp
    (42) rexp -> . rexp DIFFERENT aexp
    (43) rexp -> . aexp
    (72) empty -> .
    (44) aexp -> . aexp PLUS mexp
    (45) aexp -> . aexp MINUS mexp
    (46) aexp -> . mexp
    (47) mexp -> . mexp TIMES sexp
    (48) mexp -> . sexp
    (49) sexp -> . NOT sexp
    (50) sexp -> . MINUS sexp
    (51) sexp -> . TRUE
    (52) sexp -> . FALSE
    (53) sexp -> . NUMBER
    (54) sexp -> . NULL
    (55) sexp -> . NEW INT LBRACKET exp RBRACKET
    (56) sexp -> . pexp DOT LENGTH
    (57) sexp -> . ID DOT LENGTH
    (58) sexp -> . pexp LBRACKET exp RBRACKET
    (59) sexp -> . ID LBRACKET exp RBRACKET
    (60) sexp -> . ID
    (61) pexp -> . THIS
    (62) pexp -> . NEW ID LPAREN RPAREN
    (63) pexp -> . LPAREN exp RPAREN
    (64) pexp -> . pexp DOT ID
    (65) pexp -> . ID DOT ID
    (66) pexp -> . pexp DOT ID LPAREN exps RPAREN
    (67) pexp -> . pexp DOT ID LPAREN RPAREN
    (68) pexp -> . ID DOT ID LPAREN exps RPAREN
    (69) pexp -> . ID DOT ID LPAREN RPAREN

  ! shift/reduce conflict for RPAREN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
    RPAREN          shift and go to state 204
    PUBLIC          reduce using rule 72 (empty -> .)
    RCURLY          reduce using rule 72 (empty -> .)
    INT             reduce using rule 72 (empty -> .)
    BOOLEAN         reduce using rule 72 (empty -> .)
    RETURN          reduce using rule 72 (empty -> .)
    LCURLY          reduce using rule 72 (empty -> .)
    IF              reduce using rule 72 (empty -> .)
    WHILE           reduce using rule 72 (empty -> .)
    PRINTLN         reduce using rule 72 (empty -> .)
    ELSE            reduce using rule 72 (empty -> .)
    SEMICOLON       reduce using rule 72 (empty -> .)
    RBRACKET        reduce using rule 72 (empty -> .)
    AND             reduce using rule 72 (empty -> .)
    COMMA           reduce using rule 72 (empty -> .)
    NOT             shift and go to state 122
    MINUS           shift and go to state 120
    TRUE            shift and go to state 123
    FALSE           shift and go to state 124
    NUMBER          shift and go to state 125
    NULL            shift and go to state 126
    NEW             shift and go to state 127
    ID              shift and go to state 114
    THIS            shift and go to state 129
    LPAREN          shift and go to state 130

  ! ID              [ reduce using rule 72 (empty -> .) ]
  ! RPAREN          [ reduce using rule 72 (empty -> .) ]

    exps                           shift and go to state 203
    exp                            shift and go to state 205
    rexp                           shift and go to state 116
    empty                          shift and go to state 117
    aexp                           shift and go to state 118
    mexp                           shift and go to state 119
    sexp                           shift and go to state 121
    pexp                           shift and go to state 128

state 195

    (59) sexp -> ID LBRACKET exp RBRACKET .

    SEMICOLON       reduce using rule 59 (sexp -> ID LBRACKET exp RBRACKET .)
    RPAREN          reduce using rule 59 (sexp -> ID LBRACKET exp RBRACKET .)
    RBRACKET        reduce using rule 59 (sexp -> ID LBRACKET exp RBRACKET .)
    AND             reduce using rule 59 (sexp -> ID LBRACKET exp RBRACKET .)
    LTHAN           reduce using rule 59 (sexp -> ID LBRACKET exp RBRACKET .)
    EQUALS          reduce using rule 59 (sexp -> ID LBRACKET exp RBRACKET .)
    DIFFERENT       reduce using rule 59 (sexp -> ID LBRACKET exp RBRACKET .)
    PLUS            reduce using rule 59 (sexp -> ID LBRACKET exp RBRACKET .)
    MINUS           reduce using rule 59 (sexp -> ID LBRACKET exp RBRACKET .)
    TIMES           reduce using rule 59 (sexp -> ID LBRACKET exp RBRACKET .)
    COMMA           reduce using rule 59 (sexp -> ID LBRACKET exp RBRACKET .)


state 196

    (55) sexp -> NEW INT LBRACKET exp . RBRACKET
    (37) exp -> exp . AND rexp

    RBRACKET        shift and go to state 206
    AND             shift and go to state 145


state 197

    (62) pexp -> NEW ID LPAREN RPAREN .

    DOT             reduce using rule 62 (pexp -> NEW ID LPAREN RPAREN .)
    LBRACKET        reduce using rule 62 (pexp -> NEW ID LPAREN RPAREN .)


state 198

    (66) pexp -> pexp DOT ID LPAREN . exps RPAREN
    (67) pexp -> pexp DOT ID LPAREN . RPAREN
    (70) exps -> . exp
    (71) exps -> . exps COMMA exp
    (37) exp -> . exp AND rexp
    (38) exp -> . rexp
    (39) exp -> . empty
    (40) rexp -> . rexp LTHAN aexp
    (41) rexp -> . rexp EQUALS aexp
    (42) rexp -> . rexp DIFFERENT aexp
    (43) rexp -> . aexp
    (72) empty -> .
    (44) aexp -> . aexp PLUS mexp
    (45) aexp -> . aexp MINUS mexp
    (46) aexp -> . mexp
    (47) mexp -> . mexp TIMES sexp
    (48) mexp -> . sexp
    (49) sexp -> . NOT sexp
    (50) sexp -> . MINUS sexp
    (51) sexp -> . TRUE
    (52) sexp -> . FALSE
    (53) sexp -> . NUMBER
    (54) sexp -> . NULL
    (55) sexp -> . NEW INT LBRACKET exp RBRACKET
    (56) sexp -> . pexp DOT LENGTH
    (57) sexp -> . ID DOT LENGTH
    (58) sexp -> . pexp LBRACKET exp RBRACKET
    (59) sexp -> . ID LBRACKET exp RBRACKET
    (60) sexp -> . ID
    (61) pexp -> . THIS
    (62) pexp -> . NEW ID LPAREN RPAREN
    (63) pexp -> . LPAREN exp RPAREN
    (64) pexp -> . pexp DOT ID
    (65) pexp -> . ID DOT ID
    (66) pexp -> . pexp DOT ID LPAREN exps RPAREN
    (67) pexp -> . pexp DOT ID LPAREN RPAREN
    (68) pexp -> . ID DOT ID LPAREN exps RPAREN
    (69) pexp -> . ID DOT ID LPAREN RPAREN

  ! shift/reduce conflict for RPAREN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
    RPAREN          shift and go to state 208
    PUBLIC          reduce using rule 72 (empty -> .)
    RCURLY          reduce using rule 72 (empty -> .)
    INT             reduce using rule 72 (empty -> .)
    BOOLEAN         reduce using rule 72 (empty -> .)
    RETURN          reduce using rule 72 (empty -> .)
    LCURLY          reduce using rule 72 (empty -> .)
    IF              reduce using rule 72 (empty -> .)
    WHILE           reduce using rule 72 (empty -> .)
    PRINTLN         reduce using rule 72 (empty -> .)
    ELSE            reduce using rule 72 (empty -> .)
    SEMICOLON       reduce using rule 72 (empty -> .)
    RBRACKET        reduce using rule 72 (empty -> .)
    AND             reduce using rule 72 (empty -> .)
    COMMA           reduce using rule 72 (empty -> .)
    NOT             shift and go to state 122
    MINUS           shift and go to state 120
    TRUE            shift and go to state 123
    FALSE           shift and go to state 124
    NUMBER          shift and go to state 125
    NULL            shift and go to state 126
    NEW             shift and go to state 127
    ID              shift and go to state 114
    THIS            shift and go to state 129
    LPAREN          shift and go to state 130

  ! ID              [ reduce using rule 72 (empty -> .) ]
  ! RPAREN          [ reduce using rule 72 (empty -> .) ]

    pexp                           shift and go to state 128
    exps                           shift and go to state 207
    exp                            shift and go to state 205
    rexp                           shift and go to state 116
    empty                          shift and go to state 117
    aexp                           shift and go to state 118
    mexp                           shift and go to state 119
    sexp                           shift and go to state 121

state 199

    (58) sexp -> pexp LBRACKET exp RBRACKET .

    SEMICOLON       reduce using rule 58 (sexp -> pexp LBRACKET exp RBRACKET .)
    RPAREN          reduce using rule 58 (sexp -> pexp LBRACKET exp RBRACKET .)
    RBRACKET        reduce using rule 58 (sexp -> pexp LBRACKET exp RBRACKET .)
    AND             reduce using rule 58 (sexp -> pexp LBRACKET exp RBRACKET .)
    LTHAN           reduce using rule 58 (sexp -> pexp LBRACKET exp RBRACKET .)
    EQUALS          reduce using rule 58 (sexp -> pexp LBRACKET exp RBRACKET .)
    DIFFERENT       reduce using rule 58 (sexp -> pexp LBRACKET exp RBRACKET .)
    PLUS            reduce using rule 58 (sexp -> pexp LBRACKET exp RBRACKET .)
    MINUS           reduce using rule 58 (sexp -> pexp LBRACKET exp RBRACKET .)
    TIMES           reduce using rule 58 (sexp -> pexp LBRACKET exp RBRACKET .)
    COMMA           reduce using rule 58 (sexp -> pexp LBRACKET exp RBRACKET .)


state 200

    (35) cmd -> ID LBRACKET exp RBRACKET ASSIGN exp . SEMICOLON
    (37) exp -> exp . AND rexp

    SEMICOLON       shift and go to state 209
    AND             shift and go to state 145


state 201

    (31) cmd -> IF LPAREN exp RPAREN cmd ELSE . cmd
    (29) cmd -> . LCURLY cmds RCURLY
    (30) cmd -> . IF LPAREN exp RPAREN cmd
    (31) cmd -> . IF LPAREN exp RPAREN cmd ELSE cmd
    (32) cmd -> . WHILE LPAREN exp RPAREN cmd
    (33) cmd -> . PRINTLN LPAREN exp RPAREN SEMICOLON
    (34) cmd -> . ID ASSIGN exp SEMICOLON
    (35) cmd -> . ID LBRACKET exp RBRACKET ASSIGN exp SEMICOLON
    (36) cmd -> . empty
    (72) empty -> .

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for LCURLY resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for PRINTLN resolved as shift
    LCURLY          shift and go to state 88
    IF              shift and go to state 91
    WHILE           shift and go to state 92
    PRINTLN         shift and go to state 93
    ID              shift and go to state 103
    PUBLIC          reduce using rule 72 (empty -> .)
    RCURLY          reduce using rule 72 (empty -> .)
    INT             reduce using rule 72 (empty -> .)
    BOOLEAN         reduce using rule 72 (empty -> .)
    RETURN          reduce using rule 72 (empty -> .)
    ELSE            reduce using rule 72 (empty -> .)
    SEMICOLON       reduce using rule 72 (empty -> .)
    RPAREN          reduce using rule 72 (empty -> .)
    RBRACKET        reduce using rule 72 (empty -> .)
    AND             reduce using rule 72 (empty -> .)
    COMMA           reduce using rule 72 (empty -> .)

  ! ID              [ reduce using rule 72 (empty -> .) ]
  ! LCURLY          [ reduce using rule 72 (empty -> .) ]
  ! IF              [ reduce using rule 72 (empty -> .) ]
  ! WHILE           [ reduce using rule 72 (empty -> .) ]
  ! PRINTLN         [ reduce using rule 72 (empty -> .) ]

    cmd                            shift and go to state 210
    empty                          shift and go to state 94

state 202

    (17) metodo -> PUBLIC ID ID LPAREN params RPAREN LCURLY vars cmds RETURN exp SEMICOLON RCURLY .

    RCURLY          reduce using rule 17 (metodo -> PUBLIC ID ID LPAREN params RPAREN LCURLY vars cmds RETURN exp SEMICOLON RCURLY .)
    PUBLIC          reduce using rule 17 (metodo -> PUBLIC ID ID LPAREN params RPAREN LCURLY vars cmds RETURN exp SEMICOLON RCURLY .)


state 203

    (68) pexp -> ID DOT ID LPAREN exps . RPAREN
    (71) exps -> exps . COMMA exp

    RPAREN          shift and go to state 211
    COMMA           shift and go to state 212


state 204

    (69) pexp -> ID DOT ID LPAREN RPAREN .

    DOT             reduce using rule 69 (pexp -> ID DOT ID LPAREN RPAREN .)
    LBRACKET        reduce using rule 69 (pexp -> ID DOT ID LPAREN RPAREN .)


state 205

    (70) exps -> exp .
    (37) exp -> exp . AND rexp

    RPAREN          reduce using rule 70 (exps -> exp .)
    COMMA           reduce using rule 70 (exps -> exp .)
    AND             shift and go to state 145


state 206

    (55) sexp -> NEW INT LBRACKET exp RBRACKET .

    SEMICOLON       reduce using rule 55 (sexp -> NEW INT LBRACKET exp RBRACKET .)
    RPAREN          reduce using rule 55 (sexp -> NEW INT LBRACKET exp RBRACKET .)
    RBRACKET        reduce using rule 55 (sexp -> NEW INT LBRACKET exp RBRACKET .)
    AND             reduce using rule 55 (sexp -> NEW INT LBRACKET exp RBRACKET .)
    LTHAN           reduce using rule 55 (sexp -> NEW INT LBRACKET exp RBRACKET .)
    EQUALS          reduce using rule 55 (sexp -> NEW INT LBRACKET exp RBRACKET .)
    DIFFERENT       reduce using rule 55 (sexp -> NEW INT LBRACKET exp RBRACKET .)
    PLUS            reduce using rule 55 (sexp -> NEW INT LBRACKET exp RBRACKET .)
    MINUS           reduce using rule 55 (sexp -> NEW INT LBRACKET exp RBRACKET .)
    TIMES           reduce using rule 55 (sexp -> NEW INT LBRACKET exp RBRACKET .)
    COMMA           reduce using rule 55 (sexp -> NEW INT LBRACKET exp RBRACKET .)


state 207

    (66) pexp -> pexp DOT ID LPAREN exps . RPAREN
    (71) exps -> exps . COMMA exp

    RPAREN          shift and go to state 213
    COMMA           shift and go to state 212


state 208

    (67) pexp -> pexp DOT ID LPAREN RPAREN .

    DOT             reduce using rule 67 (pexp -> pexp DOT ID LPAREN RPAREN .)
    LBRACKET        reduce using rule 67 (pexp -> pexp DOT ID LPAREN RPAREN .)


state 209

    (35) cmd -> ID LBRACKET exp RBRACKET ASSIGN exp SEMICOLON .

    RCURLY          reduce using rule 35 (cmd -> ID LBRACKET exp RBRACKET ASSIGN exp SEMICOLON .)
    RETURN          reduce using rule 35 (cmd -> ID LBRACKET exp RBRACKET ASSIGN exp SEMICOLON .)
    LCURLY          reduce using rule 35 (cmd -> ID LBRACKET exp RBRACKET ASSIGN exp SEMICOLON .)
    IF              reduce using rule 35 (cmd -> ID LBRACKET exp RBRACKET ASSIGN exp SEMICOLON .)
    WHILE           reduce using rule 35 (cmd -> ID LBRACKET exp RBRACKET ASSIGN exp SEMICOLON .)
    PRINTLN         reduce using rule 35 (cmd -> ID LBRACKET exp RBRACKET ASSIGN exp SEMICOLON .)
    ID              reduce using rule 35 (cmd -> ID LBRACKET exp RBRACKET ASSIGN exp SEMICOLON .)
    ELSE            reduce using rule 35 (cmd -> ID LBRACKET exp RBRACKET ASSIGN exp SEMICOLON .)


state 210

    (31) cmd -> IF LPAREN exp RPAREN cmd ELSE cmd .

    RCURLY          reduce using rule 31 (cmd -> IF LPAREN exp RPAREN cmd ELSE cmd .)
    RETURN          reduce using rule 31 (cmd -> IF LPAREN exp RPAREN cmd ELSE cmd .)
    LCURLY          reduce using rule 31 (cmd -> IF LPAREN exp RPAREN cmd ELSE cmd .)
    IF              reduce using rule 31 (cmd -> IF LPAREN exp RPAREN cmd ELSE cmd .)
    WHILE           reduce using rule 31 (cmd -> IF LPAREN exp RPAREN cmd ELSE cmd .)
    PRINTLN         reduce using rule 31 (cmd -> IF LPAREN exp RPAREN cmd ELSE cmd .)
    ID              reduce using rule 31 (cmd -> IF LPAREN exp RPAREN cmd ELSE cmd .)
    ELSE            reduce using rule 31 (cmd -> IF LPAREN exp RPAREN cmd ELSE cmd .)


state 211

    (68) pexp -> ID DOT ID LPAREN exps RPAREN .

    DOT             reduce using rule 68 (pexp -> ID DOT ID LPAREN exps RPAREN .)
    LBRACKET        reduce using rule 68 (pexp -> ID DOT ID LPAREN exps RPAREN .)


state 212

    (71) exps -> exps COMMA . exp
    (37) exp -> . exp AND rexp
    (38) exp -> . rexp
    (39) exp -> . empty
    (40) rexp -> . rexp LTHAN aexp
    (41) rexp -> . rexp EQUALS aexp
    (42) rexp -> . rexp DIFFERENT aexp
    (43) rexp -> . aexp
    (72) empty -> .
    (44) aexp -> . aexp PLUS mexp
    (45) aexp -> . aexp MINUS mexp
    (46) aexp -> . mexp
    (47) mexp -> . mexp TIMES sexp
    (48) mexp -> . sexp
    (49) sexp -> . NOT sexp
    (50) sexp -> . MINUS sexp
    (51) sexp -> . TRUE
    (52) sexp -> . FALSE
    (53) sexp -> . NUMBER
    (54) sexp -> . NULL
    (55) sexp -> . NEW INT LBRACKET exp RBRACKET
    (56) sexp -> . pexp DOT LENGTH
    (57) sexp -> . ID DOT LENGTH
    (58) sexp -> . pexp LBRACKET exp RBRACKET
    (59) sexp -> . ID LBRACKET exp RBRACKET
    (60) sexp -> . ID
    (61) pexp -> . THIS
    (62) pexp -> . NEW ID LPAREN RPAREN
    (63) pexp -> . LPAREN exp RPAREN
    (64) pexp -> . pexp DOT ID
    (65) pexp -> . ID DOT ID
    (66) pexp -> . pexp DOT ID LPAREN exps RPAREN
    (67) pexp -> . pexp DOT ID LPAREN RPAREN
    (68) pexp -> . ID DOT ID LPAREN exps RPAREN
    (69) pexp -> . ID DOT ID LPAREN RPAREN

  ! shift/reduce conflict for ID resolved as shift
    PUBLIC          reduce using rule 72 (empty -> .)
    RCURLY          reduce using rule 72 (empty -> .)
    INT             reduce using rule 72 (empty -> .)
    BOOLEAN         reduce using rule 72 (empty -> .)
    RETURN          reduce using rule 72 (empty -> .)
    LCURLY          reduce using rule 72 (empty -> .)
    IF              reduce using rule 72 (empty -> .)
    WHILE           reduce using rule 72 (empty -> .)
    PRINTLN         reduce using rule 72 (empty -> .)
    ELSE            reduce using rule 72 (empty -> .)
    SEMICOLON       reduce using rule 72 (empty -> .)
    RPAREN          reduce using rule 72 (empty -> .)
    RBRACKET        reduce using rule 72 (empty -> .)
    AND             reduce using rule 72 (empty -> .)
    COMMA           reduce using rule 72 (empty -> .)
    NOT             shift and go to state 122
    MINUS           shift and go to state 120
    TRUE            shift and go to state 123
    FALSE           shift and go to state 124
    NUMBER          shift and go to state 125
    NULL            shift and go to state 126
    NEW             shift and go to state 127
    ID              shift and go to state 114
    THIS            shift and go to state 129
    LPAREN          shift and go to state 130

  ! ID              [ reduce using rule 72 (empty -> .) ]

    exp                            shift and go to state 214
    rexp                           shift and go to state 116
    empty                          shift and go to state 117
    aexp                           shift and go to state 118
    mexp                           shift and go to state 119
    sexp                           shift and go to state 121
    pexp                           shift and go to state 128

state 213

    (66) pexp -> pexp DOT ID LPAREN exps RPAREN .

    DOT             reduce using rule 66 (pexp -> pexp DOT ID LPAREN exps RPAREN .)
    LBRACKET        reduce using rule 66 (pexp -> pexp DOT ID LPAREN exps RPAREN .)


state 214

    (71) exps -> exps COMMA exp .
    (37) exp -> exp . AND rexp

    RPAREN          reduce using rule 71 (exps -> exps COMMA exp .)
    COMMA           reduce using rule 71 (exps -> exps COMMA exp .)
    AND             shift and go to state 145

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ID in state 15 resolved as shift
WARNING: shift/reduce conflict for INT in state 15 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 15 resolved as shift
WARNING: shift/reduce conflict for PUBLIC in state 20 resolved as shift
WARNING: shift/reduce conflict for ID in state 20 resolved as shift
WARNING: shift/reduce conflict for INT in state 20 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 20 resolved as shift
WARNING: shift/reduce conflict for ID in state 28 resolved as shift
WARNING: shift/reduce conflict for INT in state 28 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 28 resolved as shift
WARNING: shift/reduce conflict for PUBLIC in state 30 resolved as shift
WARNING: shift/reduce conflict for RCURLY in state 30 resolved as shift
WARNING: shift/reduce conflict for PUBLIC in state 39 resolved as shift
WARNING: shift/reduce conflict for ID in state 39 resolved as shift
WARNING: shift/reduce conflict for INT in state 39 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 39 resolved as shift
WARNING: shift/reduce conflict for PUBLIC in state 49 resolved as shift
WARNING: shift/reduce conflict for RCURLY in state 49 resolved as shift
WARNING: shift/reduce conflict for ID in state 71 resolved as shift
WARNING: shift/reduce conflict for INT in state 71 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 71 resolved as shift
WARNING: shift/reduce conflict for ID in state 73 resolved as shift
WARNING: shift/reduce conflict for INT in state 73 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 73 resolved as shift
WARNING: shift/reduce conflict for ID in state 76 resolved as shift
WARNING: shift/reduce conflict for INT in state 76 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 76 resolved as shift
WARNING: shift/reduce conflict for ID in state 79 resolved as shift
WARNING: shift/reduce conflict for INT in state 79 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 79 resolved as shift
WARNING: shift/reduce conflict for LCURLY in state 79 resolved as shift
WARNING: shift/reduce conflict for IF in state 79 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 79 resolved as shift
WARNING: shift/reduce conflict for PRINTLN in state 79 resolved as shift
WARNING: shift/reduce conflict for ID in state 80 resolved as shift
WARNING: shift/reduce conflict for INT in state 80 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 80 resolved as shift
WARNING: shift/reduce conflict for ID in state 81 resolved as shift
WARNING: shift/reduce conflict for INT in state 81 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 81 resolved as shift
WARNING: shift/reduce conflict for LCURLY in state 81 resolved as shift
WARNING: shift/reduce conflict for IF in state 81 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 81 resolved as shift
WARNING: shift/reduce conflict for PRINTLN in state 81 resolved as shift
WARNING: shift/reduce conflict for ID in state 84 resolved as shift
WARNING: shift/reduce conflict for INT in state 84 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 84 resolved as shift
WARNING: shift/reduce conflict for LCURLY in state 84 resolved as shift
WARNING: shift/reduce conflict for IF in state 84 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 84 resolved as shift
WARNING: shift/reduce conflict for PRINTLN in state 84 resolved as shift
WARNING: shift/reduce conflict for ID in state 88 resolved as shift
WARNING: shift/reduce conflict for LCURLY in state 88 resolved as shift
WARNING: shift/reduce conflict for IF in state 88 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 88 resolved as shift
WARNING: shift/reduce conflict for PRINTLN in state 88 resolved as shift
WARNING: shift/reduce conflict for ID in state 89 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 89 resolved as shift
WARNING: shift/reduce conflict for LCURLY in state 89 resolved as shift
WARNING: shift/reduce conflict for IF in state 89 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 89 resolved as shift
WARNING: shift/reduce conflict for PRINTLN in state 89 resolved as shift
WARNING: shift/reduce conflict for ID in state 95 resolved as shift
WARNING: shift/reduce conflict for INT in state 95 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 95 resolved as shift
WARNING: shift/reduce conflict for LCURLY in state 95 resolved as shift
WARNING: shift/reduce conflict for IF in state 95 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 95 resolved as shift
WARNING: shift/reduce conflict for PRINTLN in state 95 resolved as shift
WARNING: shift/reduce conflict for ID in state 96 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 96 resolved as shift
WARNING: shift/reduce conflict for LCURLY in state 96 resolved as shift
WARNING: shift/reduce conflict for IF in state 96 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 96 resolved as shift
WARNING: shift/reduce conflict for PRINTLN in state 96 resolved as shift
WARNING: shift/reduce conflict for ID in state 98 resolved as shift
WARNING: shift/reduce conflict for LCURLY in state 98 resolved as shift
WARNING: shift/reduce conflict for IF in state 98 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 98 resolved as shift
WARNING: shift/reduce conflict for PRINTLN in state 98 resolved as shift
WARNING: shift/reduce conflict for ID in state 99 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 99 resolved as shift
WARNING: shift/reduce conflict for LCURLY in state 99 resolved as shift
WARNING: shift/reduce conflict for IF in state 99 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 99 resolved as shift
WARNING: shift/reduce conflict for PRINTLN in state 99 resolved as shift
WARNING: shift/reduce conflict for ID in state 100 resolved as shift
WARNING: shift/reduce conflict for ID in state 101 resolved as shift
WARNING: shift/reduce conflict for RCURLY in state 102 resolved as shift
WARNING: shift/reduce conflict for ID in state 102 resolved as shift
WARNING: shift/reduce conflict for LCURLY in state 102 resolved as shift
WARNING: shift/reduce conflict for IF in state 102 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 102 resolved as shift
WARNING: shift/reduce conflict for PRINTLN in state 102 resolved as shift
WARNING: shift/reduce conflict for ID in state 104 resolved as shift
WARNING: shift/reduce conflict for ID in state 106 resolved as shift
WARNING: shift/reduce conflict for ID in state 107 resolved as shift
WARNING: shift/reduce conflict for ID in state 108 resolved as shift
WARNING: shift/reduce conflict for ID in state 109 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 109 resolved as shift
WARNING: shift/reduce conflict for LCURLY in state 109 resolved as shift
WARNING: shift/reduce conflict for IF in state 109 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 109 resolved as shift
WARNING: shift/reduce conflict for PRINTLN in state 109 resolved as shift
WARNING: shift/reduce conflict for ID in state 110 resolved as shift
WARNING: shift/reduce conflict for ID in state 111 resolved as shift
WARNING: shift/reduce conflict for LCURLY in state 111 resolved as shift
WARNING: shift/reduce conflict for IF in state 111 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 111 resolved as shift
WARNING: shift/reduce conflict for PRINTLN in state 111 resolved as shift
WARNING: shift/reduce conflict for ID in state 113 resolved as shift
WARNING: shift/reduce conflict for ID in state 130 resolved as shift
WARNING: shift/reduce conflict for ID in state 137 resolved as shift
WARNING: shift/reduce conflict for ID in state 143 resolved as shift
WARNING: shift/reduce conflict for ID in state 157 resolved as shift
WARNING: shift/reduce conflict for ID in state 161 resolved as shift
WARNING: shift/reduce conflict for LCURLY in state 161 resolved as shift
WARNING: shift/reduce conflict for IF in state 161 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 161 resolved as shift
WARNING: shift/reduce conflict for PRINTLN in state 161 resolved as shift
WARNING: shift/reduce conflict for ID in state 162 resolved as shift
WARNING: shift/reduce conflict for LCURLY in state 162 resolved as shift
WARNING: shift/reduce conflict for IF in state 162 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 162 resolved as shift
WARNING: shift/reduce conflict for PRINTLN in state 162 resolved as shift
WARNING: shift/reduce conflict for ID in state 179 resolved as shift
WARNING: shift/reduce conflict for ID in state 185 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 187 resolved as shift
WARNING: shift/reduce conflict for RPAREN in state 194 resolved as shift
WARNING: shift/reduce conflict for ID in state 194 resolved as shift
WARNING: shift/reduce conflict for RPAREN in state 198 resolved as shift
WARNING: shift/reduce conflict for ID in state 198 resolved as shift
WARNING: shift/reduce conflict for ID in state 201 resolved as shift
WARNING: shift/reduce conflict for LCURLY in state 201 resolved as shift
WARNING: shift/reduce conflict for IF in state 201 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 201 resolved as shift
WARNING: shift/reduce conflict for PRINTLN in state 201 resolved as shift
WARNING: shift/reduce conflict for ID in state 212 resolved as shift
